---
categories:
- 技术文章
date: '2007-12-27'
title: C#程序实现动态调用DLL的研究(转载)
url: /2007/12/27/1016924/

---


<div class="postbody">

**<span>C#</span>****<span>程序实现动态调用</span>****<span>DLL</span>****<span>的研究</span>**

<span>摘</span>&nbsp;<span>要：</span><span>在《</span><span>csdn</span><span>开发高手》</span><span>2004</span><span>年第</span><span>03</span><span>期中的《化功大法——将</span><span>DLL</span><span>嵌入</span><span>EXE</span><span>》一文，介绍了如何把一个动态链接库作为一个资源嵌入到可执行文件，在可执行文件运行时，自动从资源中释放出来，通过静态加载延迟实现ＤＬＬ函数的动态加载，程序退出后实现临时文件的自动删除，从而为解决&#8220;</span><span>DLL Hell</span><span>&#8221;提供了一种解决方案。这是一个很好的设计思想，而且该作者也用</span><span>C++</span><span>实现了，在</span><span>Internet</span><span>上也有相似的</span><span>VB</span><span>程序，但在某一技术论坛上提起这种设计方法时，有网友提出：&#8220;这种方法好是好，但就是启动速度太慢&#8221;。这是因为程序启动时实现</span><span>DLL</span><span>释放，然后再加载释放出来的</span><span>DLL</span><span>，这个过程会耗费一定的时间。鉴于此问题，经过思索，提出另一个设计方案：</span><span>DLL</span><span>作为资源文件嵌入程序，但不需进行</span><span>DLL</span><span>释放及其重新加载。本文就是对该设计方案的原理分析及使用</span><span>C#</span><span>编程来实现该设计方案。</span>

&nbsp;

<span>关键词：</span><span>动态调用</span><span>DLL</span><span>，嵌入</span><span>DLL</span><span>，</span><span>C#</span>

&nbsp;

<span>正</span>&nbsp;<span>文：</span>

**<span>一、<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>DLL</span>****<span>与应用程序</span>**

<span>动态链接库（也称为</span><span>DLL</span><span>，即为&#8220;</span><span>Dynamic Link Library</span><span>&#8221;的缩写）是</span><span>Microsoft Windows</span><span>最重要的组成要素之一，打开</span><span>Windows</span><span>系统文件夹，你会发现文件夹中有很多</span><span>DLL</span><span>文件，</span><span>Windows</span><span>就是将一些主要的系统功能以</span><span>DLL</span><span>模块的形式实现。</span> 

<span>动态链接库是不能直接执行的，也不能接收消息，它只是一个独立的文件，其中包含能被程序或其它</span><span>DLL</span><span>调用来完成一定操作的函数</span><span>(</span><span>方法。注：</span><span>C#</span><span>中一般称为&#8220;方法&#8221;</span><span>)</span><span>，但这些函数不是执行程序本身的一部分，而是根据进程的需要按需载入，此时才能发挥作用。</span>

<span>DLL</span><span>只有在应用程序需要时才被系统加载到进程的虚拟空间中，成为调用进程的一部分，此时该</span><span>DLL</span><span>也只能被该进程的线程访问，它的句柄可以被调用进程所使用，而调用进程的句柄也可以被该</span><span>DLL</span><span>所使用。在内存中，一个</span><span>DLL</span><span>只有一个实例，且它的编制与具体的编程语言和编译器都没有关系，所以可以通过</span><span>DLL</span><span>来实现混合语言编程。</span><span>DLL</span><span>函数中的代码所创建的任何对象（包括变量）都归调用它的线程或进程所有。</span>

<span>下面列出了当程序使用</span><span> DLL </span><span>时提供的一些优点：</span><span>[1]</span>

**<span>1)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>使用较少的资源</span>**

<span>当多个程序使用同一个函数库时，</span><span>DLL </span><span>可以减少在磁盘和物理内存中加载的代码的重复量。这不仅可以大大影响在前台运行的程序，而且可以大大影响其他在</span><span> Windows </span><span>操作系统上运行的程序。</span><span> </span>

**<span>2)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>推广模块式体系结构</span>**

<span>DLL </span><span>有助于促进模块式程序的开发。这可以帮助您开发要求提供多个语言版本的大型程序或要求具有模块式体系结构的程序。模块式程序的一个示例是具有多个可以在运行时动态加载的模块的计帐程序。</span><span> </span>

**<span>3)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>简化部署和安装</span>**

<span>当</span><span> DLL </span><span>中的函数需要更新或修复时，部署和安装</span><span> DLL </span><span>不要求重新建立程序与该</span><span> DLL </span><span>的链接。此外，如果多个程序使用同一个</span><span> DLL</span><span>，那么多个程序都将从该更新或修复中获益。当您使用定期更新或修复的第三方</span><span> DLL </span><span>时，此问题可能会更频繁地出现。</span>

**<span>二、<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>DLL</span>****<span>的调用</span>**

<span>每种编程语言调用</span><span>DLL</span><span>的方法都不尽相同，在此只对用</span><span>C#</span><span>调用</span><span>DLL</span><span>的方法进行介绍。首先</span><span>,</span><span>您需要了解什么是托管</span><span>,</span><span>什么是非托管。一般可以认为：非托管代码主要是基于</span><span>win 32</span><span>平台开发的</span><span>DLL</span><span>，</span><span>activeX</span><span>的组件，托管代码是基于</span><span>.net</span><span>平台开发的。如果您想深入了解托管与非托管的关系与区别，及它们的运行机制，请您自行查找资料，本文件在此不作讨论。</span>

**<span>(一)<span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>调用</span>****<span>DLL</span>****<span>中的非托管函数一般方法</span>**

**<span>首先</span>**<span>，应该在</span><span>C#</span><span>语言源程序中声明外部方法，其基本形式是：</span>

<span>[DLLImport(&#8220;DLL</span><span>文件</span><span>&#8221;)]</span>

<span>修饰符</span><span> extern </span><span>返回变量类型</span> <span>方法名称</span>&nbsp;<span>（参数列表）</span>

**<span>其中</span>**<span>：</span>

<span>DLL</span><span>文件：包含定义外部方法的库文件。</span>

<span>修饰符：</span>&nbsp;<span>访问修饰符，除了</span><span>abstract</span><span>以外在声明方法时可以使用的修饰符。</span>

<span>返回变量类型：在</span><span>DLL</span><span>文件中你需调用方法的返回变量类型。</span>

<span>方法名称：在</span><span>DLL</span><span>文件中你需调用方法的名称。</span>

<span>参数列表：在</span><span>DLL</span><span>文件中你需调用方法的列表。</span>

**<span>注意</span>**<span>：需要在程序声明中使用</span><span>System.Runtime.InteropServices</span><span>命名空间。</span>

<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DllImport</span><span>只能放置在方法声明上。</span>

<span>DLL</span><span>文件必须位于程序当前目录或系统定义的查询路径中（即：系统环境变量中</span><span>Path</span><span>所设置的路径）。</span>

<span>返回变量类型、方法名称、参数列表一定要与</span><span>DLL</span><span>文件中的定义相一致。</span>

&nbsp;

<span>若要使用其它函数名，可以使用</span><span>EntryPoint</span><span>属性设置，如：</span>

<span>[DllImport("user32.dll", EntryPoint="MessageBoxA")]</span>

<span>static extern int MsgBox(int hWnd, string msg, string caption, int type);</span>

<span>其它可选的</span><span> DllImportAttribute </span><span>属性：</span>

<span>CharSet </span><span>指示用在入口点中的字符集，如：</span><span>CharSet=CharSet.Ansi</span><span>；</span>

<span>SetLastError </span><span>指示方法是否保留</span><span> Win32"</span><span>上一错误</span><span>"</span><span>，如：</span><span>SetLastError=true</span><span>；</span>

<span>ExactSpelling </span><span>指示</span><span> EntryPoint </span><span>是否必须与指示的入口点的拼写完全匹配，如：</span><span>ExactSpelling=false</span><span>；</span>

<span>PreserveSig</span><span>指示方法的签名应当被保留还是被转换，</span> <span>如：</span><span>PreserveSig=true</span><span>；</span>

<span>CallingConvention</span><span>指示入口点的调用约定，</span> <span>如：</span><span>CallingConvention=CallingConvention.Winapi</span><span>；</span>

&nbsp;

<span>此外，关于&#8220;数据封送处理&#8221;及&#8220;封送数字和逻辑标量&#8221;请参阅其它一些文章</span><span>[2]</span><span>。</span>

**<span>C#</span>****<span>例子：</span>**

<span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>启动</span><span>VS.NET</span><span>，新建一个项目，项目名称为&#8220;</span><span>Tzb</span><span>&#8221;，模板为&#8220;</span><span>Windows </span><span>应用程序&#8221;。</span>

<span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>在&#8220;工具箱&#8221;的&#8220;</span><span> Windows </span><span>窗体&#8221;项中双击&#8220;</span><span>Button</span><span>&#8221;项，向&#8220;</span><span>Form1</span><span>&#8221;窗体中添加一个按钮。</span>

<span>3.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>改变按钮的属性：</span><span>Name</span><span>为</span> <span>&#8220;B1&#8221;</span><span>，</span><span>Text</span><span>为</span> <span>&#8220;</span><span>用</span><span>DllImport</span><span>调用</span><span>DLL</span><span>弹出提示框</span><span>&#8221;</span><span>，并将按钮</span><span>B1</span><span>调整到适当大小，移到适当位置。</span>

<span>4.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>在类视图中双击&#8220;</span><span>Form1</span><span>&#8221;，打开&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>&#8221;代码视图，在&#8220;</span><span>namespace Tzb</span><span>&#8221;上面输入&#8220;</span><span>using System.Runtime.InteropServices;</span><span>&#8221;，以导入该命名空间。</span>

<span>5.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>在&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>［设计］&#8221;视图中双击按钮</span><span>B1</span><span>，在&#8220;</span><span>B1_Click</span><span>&#8221;方法上面使用关键字</span><span> static </span><span>和</span><span> extern </span><span>声明方法&#8220;</span><span>MsgBox</span><span>&#8221;，将</span><span> DllImport </span><span>属性附加到该方法，这里我们要使用的是&#8220;</span><span>user32</span><span>．</span><span>dll</span><span>&#8221;中的&#8220;</span><span>MessageBoxA</span><span>&#8221;函数，具体代码如下：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>
  
[DllImport("user32.dll", EntryPoint="MessageBoxA")] 

static extern int MsgBox(int hWnd, string msg, string caption, int type); 

            </td>
        </tr>
    </tbody>
</table>

<span>然后在&#8220;</span><span>B1_Click</span><span>&#8221;方法体内添加如下代码，以调用方法&#8220;</span><span>MsgBox</span><span>&#8221;：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

MsgBox(0," 这就是用 DllImport 调用 DLL 弹出的提示框哦！ "," 挑战杯 ",0x30); 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>6.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>按&#8220;</span><span>F5<span><span>&#8221;</span></span><span>运行该程序，并点击按钮</span>B1</span><span>，便弹出如下提示框：</span>

<div align="center">![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image005.gif)</div>

&nbsp;

**<span>(二)<span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>动态装载、调用</span>****<span>DLL</span>****<span>中的非托管函数</span>**

<span>在上面已经说明了如何用</span><span>DllImport</span><span>调用</span><span>DLL</span><span>中的非托管函数，但是这个是全局的函数，假若</span><span>DLL</span><span>中的非托管函数有一个静态变量</span><span>S</span><span>，每次调用这个函数的时候，静态变量</span><span>S</span><span>就自动加</span><span>1</span><span>。结果，当需要重新计数时，就不能得出想要的结果。下面将用例子说明：</span>

**<span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>DLL</span>****<span>的创建</span>**

**<span>1)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>启动</span><span>Visual C++ 6.0</span><span>；</span>

**<span>2)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>新建一</span><span>个&#8220;</span><span>Win32 Dynamic-Link Library</span><span>&#8221;工程，工程名称为&#8220;</span><span>Count</span><span>&#8221;；</span>

**<span>3)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>在&#8220;</span><span>Dll kind</span><span>&#8221;选择界面中选择&#8220;</span><span>A simple dll project</span><span>&#8221;；</span>

**<span>4)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>打开</span><span>Count.cpp</span><span>，添加如下代码：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

// 导出函数，使用&#8220; _stdcall &#8221; 标准调用 

extern "C" _declspec(dllexport)int _stdcall count(int init); 

            </td>
        </tr>
    </tbody>
</table>
<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

int _stdcall count(int init) 

{//count 函数，使用参数 init 初始化静态的整形变量 S ，并使 S 自加 1 后返回该值 

static int S=init; 

S++; 

return S; 

} 

            </td>
        </tr>
    </tbody>
</table>

**<span>5)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>按&#8220;</span><span>F7<span><span>&#8221;</span></span><span>进行编译，得到</span>Count.dll</span><span>（在工程目录下的</span><span>Debug</span><span>文件夹中）。</span>

&nbsp;

**<span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>用<span>DllImport</span>调用<span>DLL</span>中的<span>count</span>函数</span>**

**<span>1)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>打开项目&#8220;</span><span>Tzb</span><span>&#8221;，向&#8220;</span><span>Form1<span><span>&#8221;</span></span><span>窗体中添加一个按钮。</span></span>

**<span>2)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>改变按钮的属性：</span><span>Name</span><span>为</span> <span>&#8220;</span><span>B2</span><span>&#8221;，</span><span>Text</span><span>为</span> <span>&#8220;用</span><span>DllImport</span><span>调用</span><span>DLL</span><span>中</span><span>count</span><span>函数&#8221;，并将按钮</span><span>B1</span><span>调整到适当大小，移到适当位置。</span>

**<span>3)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>打开&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>&#8221;代码视图，使用关键字</span><span> static </span><span>和</span><span> extern </span><span>声明方法&#8220;</span><span>count</span><span>&#8221;，并使其具有来自</span><span> Count.dll </span><span>的导出函数</span><span>count</span><span>的实现，代码如下：</span>

&nbsp;

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>
  
[DllImport("Count.dll")] 

static extern int count(int init); 

            </td>
        </tr>
    </tbody>
</table>

**<span>4)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>在&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>［设计］&#8221;视图中双击按钮</span><span>B2</span><span>，在&#8220;</span><span>B2_Click</span><span>&#8221;方法体内添加如下代码：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

MessageBox.Show(" 用 DllImport 调用 DLL 中的 count 函数， \n 传入的实参为 0 ，得到的结果是： "+count(0).ToString()," 挑战杯 "); 

MessageBox.Show(" 用 DllImport 调用 DLL 中的 count 函数， \n 传入的实参为 10 ，得到的结果是： "+count(10).ToString()+"\n 结果可不是想要的 11 哦！！！ "," 挑战杯 "); 

MessageBox.Show(" 所得结果表明： \n 用 DllImport 调用 DLL 中的非托管 \n 函数是全局的、静态的函数！！！ "," 挑战杯 "); 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

**<span>5)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**<span>把</span><span>Count.dll</span><span>复制到项目&#8220;</span><span>Tzb</span><span>&#8221;的</span><span>bin\Debug</span><span>文件夹中，按&#8220;</span><span>F5<span><span>&#8221;</span></span><span>运行该程序，并点击按钮</span>B2</span><span>，便弹出如下三个提示框：</span>

&nbsp;

<div align="center">![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image013.gif) ![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image014.gif) ![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image015.gif) </div>

<span>第</span><span>1</span><span>个提示框显示的是调用&#8220;</span><span>count(0)</span><span>&#8221;的结果，第</span><span>2</span><span>个提示框显示的是调用&#8220;</span><span>count(10)</span><span>&#8221;的结果，由所得结果可以证明&#8220;用</span><span>DllImport</span><span>调用</span><span>DLL</span><span>中的非托管函数是全局的、静态的函数&#8221;。所以，有时候并不能达到我们目的，因此我们需要使用下面所介绍的方法：</span><span>C#</span><span>动态调用</span><span>DLL</span><span>中的函数。</span>

&nbsp;

<span>&nbsp;&nbsp;&nbsp; </span>

**<span>3.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>C#</span>****<span>动态调用</span>****<span>DLL</span>****<span>中的函数</span>**

<span>因为</span><span>C#</span><span>中使用</span><span>DllImport</span><span>是不能像动态</span><span>load/unload assembly</span><span>那样，所以只能借助</span><span>API</span><span>函数了。在</span><span>kernel32.dll</span><span>中，与动态库调用有关的函数包括</span><span>[3]</span><span>：</span>

<span>①</span><span>LoadLibrary</span><span>（或</span><span>MFC </span><span>的</span><span>AfxLoadLibrary</span><span>），装载动态库。</span><span> </span>

<span>②</span><span>GetProcAddress</span><span>，获取要引入的函数，将符号名或标识号转换为</span><span>DLL</span><span>内部地址。</span>

<span>③</span><span>FreeLibrary</span><span>（或</span><span>MFC</span><span>的</span><span>AfxFreeLibrary</span><span>），释放动态链接库。</span>

<span>它们的原型分别是：</span>

<span>HMODULE LoadLibrary(LPCTSTR lpFileName);</span>

<span>FARPROC GetProcAddress(HMODULE hModule, LPCWSTR lpProcName);</span>

<span>BOOL FreeLibrary(HMODULE hModule);</span>

&nbsp;

<span>现在，我们可以用</span><span>IntPtr hModule=LoadLibrary(&#8220;Count.dll&#8221;);</span><span>来获得</span><span>Dll</span><span>的句柄</span><span>,</span><span>用</span><span>IntPtr farProc=GetProcAddress(hModule,&#8221;</span><span>_count@4<span>&#8221;</span></span><span>);</span><span>来获得函数的入口地址。</span>

<span>但是，知道函数的入口地址后，怎样调用这个函数呢？因为在</span><span>C#</span><span>中是没有函数指针的，没有像</span><span>C++</span><span>那样的函数指针调用方式来调用函数，所以我们得借助其它方法。经过研究，发现我们可以通过结合使用</span><span>System.Reflection.Emit</span><span>及</span><span>System.Reflection.Assembly</span><span>里的类和函数达到我们的目的。为了以后使用方便及实现代码的复用，我们可以编写一个类。</span>

**<span>1)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>dld</span>****<span>类的编写：</span>**

<span><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span>打开项目&#8220;</span><span>Tzb</span><span>&#8221;，打开类视图，右击&#8220;</span><span>Tzb</span><span>&#8221;，选择&#8220;添加&#8221;</span><span>--&gt;</span><span>&#8220;类&#8221;，<span>类名设置为&#8220;</span></span><span><span>dld</span></span><span><span>&#8221;，即</span><span>dynamic loading dll </span></span><span><span>的每个单词的开头字母。</span></span>

<span><span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span><span>添加所需的命名空间及声明参数传递方式枚举：</span></span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

using System.Runtime.InteropServices; // 用 DllImport 需用此 命名空间 

using System.Reflection; // 使用 Assembly 类需用此 命名空间 

using System.Reflection.Emit; // 使用 ILGenerator 需用此 命名空间 

&nbsp; 

            </td>
        </tr>
    </tbody>
</table>

<span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><span>在&#8220;</span><span>public class dld</span></span><span><span>&#8221;上面添加如下代码声明参数传递方式枚举：</span></span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 参数传递方式枚举 ,ByValue 表示值传递 ,ByRef 表示址传递 

/// &lt;/summary&gt; 

public enum ModePass 

{ 

ByValue = 0x0001, 

ByRef = 0x0002 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>3.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><span>声明</span></span><span>LoadLibrary</span><span>、</span><span>GetProcAddress</span><span>、</span><span>FreeLibrary</span><span>及私有变量</span><span>hModule</span><span>和</span><span>farProc</span><span>：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 原型是 :HMODULE LoadLibrary(LPCTSTR lpFileName); 

/// &lt;/summary&gt; 

/// &lt;param name="lpFileName"&gt;DLL 文件名 &lt;/param&gt; 

/// &lt;returns&gt; 函数库模块的句柄 &lt;/returns&gt; 
  
[DllImport("kernel32.dll")] 

static extern IntPtr LoadLibrary(string lpFileName); 

/// &lt;summary&gt; 

/// 原型是 : FARPROC GetProcAddress(HMODULE hModule, LPCWSTR lpProcName); 

/// &lt;/summary&gt; 

/// &lt;param name="hModule"&gt; 包含需调用函数的函数库模块的句柄 &lt;/param&gt; 

/// &lt;param name="lpProcName"&gt; 调用函数的名称 &lt;/param&gt; 

/// &lt;returns&gt; 函数指针 &lt;/returns&gt; 
  
[DllImport("kernel32.dll")] 

static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName); 

/// &lt;summary&gt; 

/// 原型是 : BOOL FreeLibrary(HMODULE hModule); 

/// &lt;/summary&gt; 

/// &lt;param name="hModule"&gt; 需释放的函数库模块的句柄 &lt;/param&gt; 

/// &lt;returns&gt; 是否已释放指定的 Dll&lt;/returns&gt; 
  
[DllImport("kernel32",EntryPoint="FreeLibrary",SetLastError=true)] 

static extern bool FreeLibrary(IntPtr hModule); 

/// &lt;summary&gt; 

/// Loadlibrary 返回的函数库模块的句柄 

/// &lt;/summary&gt; 

private IntPtr hModule=IntPtr.Zero; 

/// &lt;summary&gt; 

/// GetProcAddress 返回的函数指针 

/// &lt;/summary&gt; 

private IntPtr farProc=IntPtr.Zero; 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>4.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>添加</span><span>LoadDll</span><span>方法，并为了调用时方便，重载了这个方法：</span>

&nbsp;

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 装载 Dll 

/// &lt;/summary&gt; 

/// &lt;param name="lpFileName"&gt;DLL 文件名 &lt;/param&gt; 

public void LoadDll(string lpFileName) 

{ 

hModule=LoadLibrary(lpFileName); 

if(hModule==IntPtr.Zero) 

throw(new Exception(" 没有找到 :"+lpFileName+"." )); 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>若已有已装载</span><span>Dll</span><span>的句柄，可以使用</span><span>LoadDll</span><span>方法的第二个版本：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

public void LoadDll(IntPtr HMODULE) 

{ 

if(HMODULE==IntPtr.Zero) 

throw(new Exception(" 所传入的函数库模块的句柄 HMODULE 为空 ." )); 

hModule=HMODULE; 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>5.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>添加</span><span>LoadFun</span><span>方法，并为了调用时方便，也重载了这个方法，方法的具体代码及注释如下：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 获得函数指针 

/// &lt;/summary&gt; 

/// &lt;param name="lpProcName"&gt; 调用函数的名称 &lt;/param&gt; 

public void LoadFun(string lpProcName) 

{ // 若函数库模块的句柄为空，则抛出异常 

if(hModule==IntPtr.Zero) 

throw(new Exception(" 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !")); 

// 取得函数指针 

farProc = GetProcAddress(hModule,lpProcName); 

// 若函数指针，则抛出异常 

if(farProc==IntPtr.Zero) 

throw(new Exception(" 没有找到 :"+lpProcName+" 这个函数的入口点 ")); 

} 

/// &lt;summary&gt; 

/// 获得函数指针 

/// &lt;/summary&gt; 

/// &lt;param name="lpFileName"&gt; 包含需调用函数的 DLL 文件名 &lt;/param&gt; 

/// &lt;param name="lpProcName"&gt; 调用函数的名称 &lt;/param&gt; 

public void LoadFun(string lpFileName,string lpProcName) 

{ // 取得函数库模块的句柄 

hModule=LoadLibrary(lpFileName); 

// 若函数库模块的句柄为空，则抛出异常 

if(hModule==IntPtr.Zero) 

throw(new Exception(" 没有找到 :"+lpFileName+"." )); 

// 取得函数指针 

farProc = GetProcAddress(hModule,lpProcName); 

// 若函数指针，则抛出异常 

if(farProc==IntPtr.Zero) 

throw(new Exception(" 没有找到 :"+lpProcName+" 这个函数的入口点 ")); 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>6.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>添加</span><span>UnLoadDll</span><span>及</span><span>Invoke</span><span>方法，</span><span>Invoke</span><span>方法也进行了重载：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 卸载 Dll 

/// &lt;/summary&gt; 

public void UnLoadDll() 

{ 

FreeLibrary(hModule); 

hModule=IntPtr.Zero; 

farProc=IntPtr.Zero; 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Invoke</span><span>方法的第一个版本：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 调用所设定的函数 

/// &lt;/summary&gt; 

/// &lt;param name="ObjArray_Parameter"&gt; 实参 &lt;/param&gt; 

/// &lt;param name="TypeArray_ParameterType"&gt; 实参类型 &lt;/param&gt; 

/// &lt;param name="ModePassArray_Parameter"&gt; 实参传送方式 &lt;/param&gt; 

/// &lt;param name="Type_Return"&gt; 返回类型 &lt;/param&gt; 

/// &lt;returns&gt; 返回所调用函数的 object&lt;/returns&gt; 

public
            object Invoke(object[] ObjArray_Parameter,Type[]
            TypeArray_ParameterType,ModePass[] ModePassArray_Parameter,Type
            Type_Return) 

{ 

// 下面 3 个 if 是进行安全检查 , 若不能通过 , 则抛出异常 

if(hModule==IntPtr.Zero) 

throw(new Exception(" 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !")); 

if(farProc==IntPtr.Zero) 

throw(new Exception(" 函数指针为空 , 请确保已进行 LoadFun 操作 !" ) ); 

if(ObjArray_Parameter.Length!=ModePassArray_Parameter.Length) 

throw(new Exception(" 参数个数及其传递方式的个数不匹配 ." ) ); 

// 下面是创建 MyAssemblyName 对象并设置其 Name 属性 

AssemblyName MyAssemblyName = new AssemblyName(); 

MyAssemblyName.Name = "InvokeFun"; 

// 生成单模块配件 

AssemblyBuilder MyAssemblyBuilder =AppDomain.CurrentDomain.DefineDynamicAssembly(MyAssemblyName,AssemblyBuilderAccess.Run); 

ModuleBuilder MyModuleBuilder =MyAssemblyBuilder.DefineDynamicModule("InvokeDll"); 

// 定义要调用的方法 , 方法名为&#8220; MyFun &#8221;，返回类型是&#8220; Type_Return &#8221;参数类型是&#8220; TypeArray_ParameterType &#8221; 

MethodBuilder
            MyMethodBuilder
            =MyModuleBuilder.DefineGlobalMethod("MyFun",MethodAttributes.Public|
            MethodAttributes.Static,Type_Return,TypeArray_ParameterType); 

// 获取一个 ILGenerator ，用于发送所需的 IL 

ILGenerator IL = MyMethodBuilder.GetILGenerator(); 

int i; 

for (i = 0; i &lt; ObjArray_Parameter.Length; i++) 

{// 用循环将参数依次压入堆栈 

switch (ModePassArray_Parameter[i]) 

{ 

case ModePass.ByValue: 

IL.Emit(OpCodes.Ldarg, i); 

break; 

case ModePass.ByRef: 

IL.Emit(OpCodes.Ldarga, i); 

break; 

default: 

throw(new Exception(" 第 " +(i+1).ToString() + " 个参数没有给定正确的传递方式 ." ) ); 

} 

} 

if (IntPtr.Size == 4) {// 判断处理器类型 

IL.Emit(OpCodes.Ldc_I4, farProc.ToInt32()); 

} 

else if (IntPtr.Size == 8) 

{ 

IL.Emit(OpCodes.Ldc_I8, farProc.ToInt64()); 

} 

else 

{ 

throw new PlatformNotSupportedException(); 

} 

IL.EmitCalli(OpCodes.Calli,CallingConvention.StdCall,Type_Return,TypeArray_ParameterType); 

IL.Emit(OpCodes.Ret); // 返回值 

MyModuleBuilder.CreateGlobalFunctions(); 

// 取得方法信息 

MethodInfo MyMethodInfo = MyModuleBuilder.GetMethod("MyFun"); 

return MyMethodInfo.Invoke(null, ObjArray_Parameter);// 调用方法，并返回其值 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Invoke</span><span>方法的第二个版本，它是调用了第一个版本的：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 调用所设定的函数 

/// &lt;/summary&gt; 

/// &lt;param name="IntPtr_Function"&gt; 函数指针 &lt;/param&gt; 

/// &lt;param name="ObjArray_Parameter"&gt; 实参 &lt;/param&gt; 

/// &lt;param name="TypeArray_ParameterType"&gt; 实参类型 &lt;/param&gt; 

/// &lt;param name="ModePassArray_Parameter"&gt; 实参传送方式 &lt;/param&gt; 

/// &lt;param name="Type_Return"&gt; 返回类型 &lt;/param&gt; 

/// &lt;returns&gt; 返回所调用函数的 object&lt;/returns&gt; 

public
            object Invoke(IntPtr IntPtr_Function,object[] ObjArray_Parameter,Type[]
            TypeArray_ParameterType,ModePass[] ModePassArray_Parameter,Type
            Type_Return) 

{ 

// 下面 2 个 if 是进行安全检查 , 若不能通过 , 则抛出异常 

if(hModule==IntPtr.Zero) 

throw(new Exception(" 函数库模块的句柄为空 , 请确保已进行 LoadDll 操作 !")); 

if(IntPtr_Function==IntPtr.Zero) 

throw(new Exception(" 函数指针 IntPtr_Function 为空 !" ) ); 

farProc=IntPtr_Function; 

return Invoke(ObjArray_Parameter,TypeArray_ParameterType,ModePassArray_Parameter,Type_Return); 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>&nbsp;</span>

**<span>2)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>dld</span>****<span>类的使用：</span>**

<span><span>1．&nbsp;</span></span><span><span>打开项目&#8220;</span><span>Tzb</span></span><span><span>&#8221;，向&#8220;</span><span>Form1<span><span>&#8221;</span></span><span>窗体中添加</span></span></span><span><span>三个按钮。</span></span><span>Name </span><span>和</span><span>Text</span><span>属性分别为</span> <span>&#8220;</span><span>B3<span><span>&#8221;</span></span></span><span>、&#8220;用</span><span>LoadLibrary</span><span>方法装载</span><span>Count.dll</span><span>&#8221;，&#8220;</span><span>B4<span><span>&#8221;</span></span></span><span>、&#8220;调用</span><span>count</span><span>方法&#8221;，&#8220;</span><span>B5<span><span>&#8221;</span></span></span><span>、&#8220;卸载</span><span>Count.dll</span><span>&#8221;，<span>并调整到适当的大小及位置</span>。</span>

<span><span>2．&nbsp;</span></span><span><span>在&#8220;</span><span>Form1</span></span><span><span>．</span><span>cs</span></span><span><span>［设计］&#8221;视图中双击按钮</span><span>B3</span></span><span><span>，在&#8220;</span><span>B3_Click</span></span><span><span>&#8221;方法体上面添加代码，创建一个</span><span>dld</span></span><span><span>类实例：</span></span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

/// &lt;summary&gt; 

/// 创建一个 dld 类对象 

/// &lt;/summary&gt; 

private dld myfun=new dld(); 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span><span>&nbsp;&nbsp;<span>3．&nbsp;</span></span></span><span><span>在&#8220;</span><span>B3_Click</span></span><span><span>&#8221;方法体内添加如下代码：</span></span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

myfun.LoadDll("Count.dll"); // 加载 "Count.dll" 

myfun.LoadFun("_count@4"); // 调入函数 count, "_count@4" 是它的入口，可通过 Depends 查看 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span><span>4．&nbsp;</span></span><span><span>&#8220;</span><span>Form1</span></span><span><span>．</span><span>cs</span></span><span><span>［设计］&#8221;视图中双击按钮</span><span>B4</span></span><span><span>，在&#8220;</span><span>B4_Click</span></span><span><span>&#8221;方法体内添加如下代码：</span></span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>
            <p>object[] Parameters = new object[]{(int)0}; // 实参为 0 

Type[] ParameterTypes = new Type[]{typeof(int)}; // 实参类型为 int 

ModePass[] themode=new ModePass[]{ModePass.ByValue}; // 传送方式为值传 

Type Type_Return = typeof(int); // 返回类型为 int 

// 弹出提示框，显示调用 myfun.Invoke 方法的结果，即调用 count 函数 

MessageBox.Show(" 这是您装载该 Dll 后第 "+myfun.Invoke(Parameters,ParameterTypes,themode,Type_Return).ToString() 

+" 次点击此按钮。 "," 挑战杯 "); 

            </td>
        </tr>
    </tbody>
</table>
<span>&nbsp;</span> </p>

<span><span>5．&nbsp;</span></span><span><span>&#8220;</span><span>Form1</span></span><span><span>．</span><span>cs</span></span><span><span>［设计］&#8221;视图中双击按钮</span><span>B5</span></span><span><span>，在&#8220;</span><span>B5_Click</span></span><span><span>&#8221;方法体内添加如下代码：</span></span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

myfun.UnLoadDll(); 

            </td>
        </tr>
    </tbody>
</table>

<span><span>6．&nbsp;</span></span><span><span>按&#8220;</span><span>F5</span></span><span><span>&#8221;运行该程序，并先点击按钮</span><span>B3</span></span><span><span>以</span></span><span>加载&#8220;<span>Count.dll</span>&#8221;</span><span><span>，接着点击按钮</span><span>B4</span></span><span><span>三次以调用</span><span>3</span></span><span><span>次&#8220;</span></span><span>count(0)</span><span>&#8221;<span>，</span>先后弹出的提示框如下<span>：</span></span>

<div align="center">![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image045.gif)![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image046.gif)![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image047.gif) </div>

<span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><span>这三个提示框所得出的结果说明了静态变量</span><span>S </span></span><span><span>经初始化后，再传入实参&#8220;</span><span>0</span><span>&#8221;</span><span>也不会改变其值为&#8220;</span><span>0</span><span>&#8221;</span><span>。</span></span>

<span><span>7．&nbsp;</span></span><span><span>点击按钮</span><span>B5</span></span><span><span>以卸载&#8220;</span><span>Count.dll</span></span><span><span>&#8221;，再点击按钮</span><span>B3</span></span><span><span>进行装载&#8220;</span><span>Count.dll</span></span><span><span>&#8221;，再点击按钮</span><span>B4</span></span><span><span>查看调用了&#8220;</span><span>count(0)</span></span><span><span>&#8221;的结果：</span></span>

<div align="center">![](http://blog.csdn.net/images/blog_csdn_net/pansiom/image048.gif) </div>

<span>从弹出的提示框所显示的结果可以看到又开始重新计数了，也就是实现了<span>DLL</span>的动态装载与卸载了。</span>

&nbsp;

<span>**<span>(三)<span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**</span><span>**<span>调用托管</span>**</span><span>**<span>DLL</span>**</span><span>**<span>一般方法</span>**</span>

<span><span>C# </span></span><span><span>调用托管</span><span>DLL</span></span><span><span>是很简单的，只要在&#8220;解决方案资源管理器&#8221;中的需要调用</span><span>DLL</span></span><span><span>的项目下用鼠标右击&#8220;引用&#8221;，并选择&#8220;添加引用&#8221;，然后选择已列出的</span><span>DLL</span></span><span><span>或通过浏览来选择</span><span>DLL</span></span><span><span>文件，最后需要用</span><span>using </span></span><span><span>导入相关的命名空间。</span></span>

<span>**<span>(四)<span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span>**</span><span>**<span>动态调用托管</span>**</span><span>**<span>DLL</span>**</span>

<span><span>C# </span></span><span><span>动态调用托管</span><span>DLL</span></span><span><span>也需要借助</span></span><span>System.Reflection.Assembly</span><span>里的类和方法，主要使用了</span><span>Assembly.LoadFrom</span><span>。现在，用例子说明：</span>

<span>&nbsp;&nbsp;&nbsp;&nbsp; </span><span>首先，启动</span><span>VS.NET</span><span>，新建一个</span><span>Visual C# </span><span>项目，使用的模板为&#8220;类库&#8221;，名称为&#8220;</span><span>CsCount</span><span>&#8221;，并在类&#8220;</span><span>Class1<span><span>&#8221;</span></span><span>中</span></span><span>添加静态整型变量</span><span>S</span><span>及方法</span><span>count</span><span>：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

// 由于 static 不能修饰方法体内的变量，所以需放在这里，且初始化值为 int.MinValue 

static int S=int.MinValue; 

public int count(int init) 

{// 判断 S 是否等于 int.MinValue ，是的话把 init 赋值给 S 

if(S==int.MinValue) S=init; 

S++; //S 自增 1 

return S; // 返回 S 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>然后，打开项目&#8220;</span><span>Tzb</span><span>&#8221;，向&#8220;</span><span>Form1<span><span>&#8221;</span></span><span>窗体中添加</span></span><span>一个按钮，</span><span>Name</span><span>属性为&#8220;</span><span>B6<span><span>&#8221;</span></span><span>，</span>Text</span><span>属性为&#8220;用</span><span>Assembly</span><span>类来动态调用托管</span><span>DLL</span><span>&#8221;，调整到适当大小和位置，双击按钮</span><span>B6</span><span>，转入代码视图，先导入命名空间：</span><span>using System.Reflection; </span><span>接着添加</span><span>Invoke</span><span>方法和</span><span>B6_Click</span><span>方法代码：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

private object Invoke(string lpFileName,string Namespace,string ClassName,string lpProcName,object[] ObjArray_Parameter) 

{ 

Try { // 载入程序集 

Assembly MyAssembly=Assembly.LoadFrom(lpFileName); 

Type[] type=MyAssembly.GetTypes(); 

foreach(Type t in type) 

{// 查找要调用的命名空间及类 

if(t.Namespace==Namespace&amp;&amp;t.Name==ClassName) 

{// 查找要调用的方法并进行调用 

MethodInfo m=t.GetMethod(lpProcName); 

if(m!=null) 

{ 

object o=Activator.CreateInstance(t); 

return m.Invoke(o,ObjArray_Parameter); 

} 

else MessageBox.Show(" 装载出错 !"); 

} 

} 

}//try 

catch(System.NullReferenceException e) 

{ 

MessageBox.Show(e.Message); 

}//catch 

return (object)0; 

}// Invoke 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>&#8220;</span><span>B6_Click</span><span>&#8221;方法体内代码如下：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

// 显示 count(0) 返回的值 

MessageBox.Show(" 这是您第 "+Invoke("CsCount.dll","CsCount","Class1","count",new object[]{(int)0}).ToString()+" 次点击此按钮。 "," 挑战杯 "); 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

<span>最后，把项目&#8220;</span><span>CsCount</span><span>&#8221;的</span><span>bin\Debug</span><span>文件夹中的</span><span>CsCount.dll</span><span>复制到项目&#8220;</span><span>Tzb</span><span>&#8221;的</span><span>bin\Debug</span><span>文件夹中，按&#8220;</span><span>F5<span><span>&#8221;</span></span><span>运行该程序，并点击按钮</span>B6</span><span>三次，将会弹出</span><span>3</span><span>个提示框，内容分别是&#8220;这是您第</span><span> 1</span><span>次点击此按钮。&#8221;、&#8220;这是您第</span><span> 2</span><span>次点击此按钮。&#8221;、&#8220;这是您第</span><span> 3</span><span>次点击此按钮。&#8221;，由此知道了静态变量</span><span>S</span><span>在这里的作用。</span>

&nbsp;

<span>**<span>(</span>**</span><span>**<span>五</span>**</span><span>**<span>) C#</span>**</span><span>**<span>程序</span>**</span>**<span>嵌入</span>****<span>DLL</span>****<span>的调用</span>**

<span><span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>DLL</span><span>文件作为资源嵌入在</span><span><span>C#</span></span><span><span>程序</span></span><span>中，我们只要读取该资源文件并以&#8220;</span><span>byte[]</span><span>&#8221;返回，然后就用&#8220;<span>Assembly Load(byte[]);</span>&#8221;得到</span><span>DLL</span><span>中的</span><span>程序集，最后就可以像上面的</span><span>Invoke</span><span>方法那样对</span><span>DLL</span><span>中的方法进行调用。当然不用上面方法也可以，如用接口实现动态调用，但</span><span>DLL</span><span>中必须有该接口的定义并且<span>程序</span>中也要有该接口的定义；也可用反射发送实现动态调用</span><span>[4]</span><span>。现在我只对</span><span>像上面的</span><span>Invoke</span><span>方法那样对</span><span>DLL</span><span>中的方法进行调用进行讨论，为了以后使用方便及实现代码的复用，我们可以结合上一个编写一个类。</span>

**<span>1)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>ldfs</span>****<span>类的编写：</span>**

<span>在项目&#8220;</span><span>Tzb</span><span>&#8221;中新建一个名为</span><span>ldfs</span><span>的类，意为&#8220;</span><span>load dll from resource</span><span>&#8221;，请注意，在这个类中&#8220;</span><span>resource</span><span>&#8221;不只是嵌入在</span><span>EXE</span><span>程序中的资源，它也可以是硬盘上任意一个</span><span>DLL</span><span>文件，这是因为</span><span>ldfs</span><span>的类中的方法</span><span>LoadDll</span><span>有些特别，就是先从程序的内嵌的资源中查找需加载的</span><span>DLL</span><span>，如果找不到，就查找硬盘上的。</span>

<span>首先导入所需的命名空间：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

using System.IO; // 对文件的读写需要用到此命名空间 

using System.Reflection; // 使用 Assembly 类需用此命名空间 

using System.Reflection.Emit; // 使用 ILGenerator 需用此命名空间 

            </td>
        </tr>
    </tbody>
</table>

<span>声明一静态变量</span><span>MyAssembly</span><span>：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

// 记录要导入的程序集 

static Assembly MyAssembly; 

            </td>
        </tr>
    </tbody>
</table>

<span>添加</span><span>LoadDll</span><span>方法：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

private byte[] LoadDll(string lpFileName) 

{ 

Assembly NowAssembly = Assembly.GetEntryAssembly(); 

Stream fs=null; 

try 

{// 尝试读取资源中的 DLL 

fs = NowAssembly.GetManifestResourceStream(NowAssembly.GetName().Name+"."+lpFileName); 

} 

finally 

{// 如果资源没有所需的 DLL ，就查看硬盘上有没有，有的话就读取 

if (fs==null&amp;&amp;!File.Exists(lpFileName)) throw(new Exception(" 找不到文件 :"+lpFileName)); 

else if(fs==null&amp;&amp;File.Exists(lpFileName)) 

{ 

FileStream Fs = new FileStream(lpFileName, FileMode.Open); 

fs=(Stream)Fs; 

} 

} 

byte[] buffer = new byte[(int) fs.Length]; 

fs.Read(buffer, 0, buffer.Length); 

fs.Close(); 

return buffer; // 以 byte[] 返回读到的 DLL 

} 

            </td>
        </tr>
    </tbody>
</table>

<span>添加</span><span>UnLoadDll</span><span>方法来卸载</span><span>DLL</span><span>：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

public void UnLoadDll() 

{// 使 MyAssembly 指空 

MyAssembly=null; 

} 

            </td>
        </tr>
    </tbody>
</table>

<span>添加</span><span>Invoke</span><span>方法来进行对</span><span>DLL</span><span>中方法的调用，其原理大体上和&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>&#8221;中的方法</span><span>Invoke</span><span>相同，不过这里用的是</span><span>&#8220;</span><span>Assembly.Load</span><span>&#8221;，而且用了</span><span>静态变量</span><span>MyAssembly</span><span>来保存已加载的</span><span>DLL</span><span>，如果已加载的话就不再加载，如果还没加载或者已加载的不同现在要加载的</span><span>DLL</span><span>就进行加载，其代码如下所示：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

public object Invoke(string lpFileName,string Namespace,string ClassName,string lpProcName,object[] ObjArray_Parameter) 

{ 

try 

{// 判断 MyAssembly 是否为空或 MyAssembly 的命名空间不等于要调用方法的命名空间，如果条件为真，就用 Assembly.Load 加载所需 DLL 作为程序集 

if(MyAssembly==null||MyAssembly.GetName().Name!=Namespace) 

MyAssembly=Assembly.Load(LoadDll(lpFileName)); 

Type[] type=MyAssembly.GetTypes(); 

foreach(Type t in type) 

{ 

if(t.Namespace==Namespace&amp;&amp;t.Name==ClassName) 

{ 

MethodInfo m=t.GetMethod(lpProcName); 

if(m!=null) 

{// 调用并返回 

object o=Activator.CreateInstance(t); 

return m.Invoke(o,ObjArray_Parameter); 

} 

else 

System.Windows.Forms.MessageBox.Show(" 装载出错 !"); 

} 

} 

} 

catch(System.NullReferenceException e) 

{ 

System.Windows.Forms.MessageBox.Show(e.Message); 

} 

return (object)0; 

} 

            </td>
        </tr>
    </tbody>
</table>

&nbsp;

&nbsp;

**<span>2)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>ldfs</span>****<span>类的使用：</span>**

<span>1．&nbsp;</span><span>把</span><span>CsCount.dll</span><span>作为&#8220;嵌入的资源&#8221;添加到项目&#8220;</span><span>Tzb</span><span>&#8221;中。</span>

<span>2．&nbsp;</span><span>向&#8220;</span><span>Form1</span><span>&#8221;窗体中添加两个按钮，</span><span>Name</span><span>和</span><span>Text</span><span>属性分别为&#8220;</span><span>B7</span><span>&#8221;、&#8220;</span><span>ldfs.Invoke</span><span>调用</span><span>count</span><span>&#8221;；&#8220;</span><span>B8</span><span>&#8221;、&#8220;</span><span>UnLoadDll</span><span>&#8221;，并将它们调整到适当大小和位置。</span>

<span>3．&nbsp;</span><span>打开&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>&#8221;代码视图，添加一个</span><span>ldfs</span><span>实例：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

// 添加一个 ldfs 实例 tmp 

private ldfs tmp=new ldfs(); 

            </td>
        </tr>
    </tbody>
</table>

<span>4．&nbsp;</span><span>在&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>［设计］&#8221;视图中双击按钮</span><span>B7</span><span>，在&#8220;</span><span>B1_Click</span><span>&#8221;方法体内添加如下代码：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

// 调用 count(0), 并使用期提示框显示其返回值 

MessageBox.Show("
            这是您第 "+tmp.Invoke("CsCount.dll","CsCount","Class1","count",new
            object[]{(int)0}).ToString()+" 次点击此按钮。 "," 挑战杯 "); 

            </td>
        </tr>
    </tbody>
</table>

<span>5．&nbsp;</span><span>在&#8220;</span><span>Form1</span><span>．</span><span>cs</span><span>［设计］&#8221;视图中双击按钮</span><span>B7</span><span>，在&#8220;</span><span>B1_Click</span><span>&#8221;方法体内添加如下代码：</span>

<table align="center" border="0" cellpadding="0" cellspacing="0" width="80%">
    <tbody>
        <tr>
            <td>

// 卸载 DLL 

tmp.UnLoadDll(); 

            </td>
        </tr>
    </tbody>
</table>

<span>6．&nbsp;</span><span>&#8220;</span><span>F5</span><span>&#8221;运行该程序，并先点击按钮</span><span>B7</span><span>三次，接着点击按钮</span><span>B8</span><span>，最后再点击按钮</span><span>B7</span><span>，此时发现又开始重新计数了，情况和&#8220;</span><span>dld</span><span>类的使用&#8221;类似，</span><span>也就是也实现了<span>DLL</span>的动态装载与卸载了</span><span>。</span>

<span>&nbsp;&nbsp;&nbsp; </span><span>说明：以上所用到的所有源代码详见附件</span><span>1:Form1.cs</span><span>、附件</span><span>2:dld.cs</span><span>、附件</span><span>3:ldfs.cs</span><span>、附件</span><span>4:Count.cpp</span><span>、附件</span><span>5:Class1.cs</span><span>。</span>

&nbsp;

**<span>三、<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>****<span>结</span>****<span> </span>****<span>论</span>**

<span>使用</span><span>DLL</span><span>有很多优点，如：节省内存和减少交换操作；开发大型程序时可以把某些模块分配给程序员，程序员可以用任何一门他所熟悉的语言把该模块编译成</span><span>DLL</span><span>文件，这样可以提高代码的复用，大大减轻程序员的工作量。当然</span><span>DLL</span><span>也有一些不足，如在提要中提及的问题。所以，如何灵活地调用</span><span>DLL</span><span>应该是每位程序员所熟知的。</span>

<span>C# </span><span>语言有很多优点，越来越多的人开始使用它来编程。但是，</span><span>C#</span><span>还有一些不足，如对不少的底层操作是无能为力的，只能通过调用</span><span>Win32 DLL </span><span>或</span><span>C++</span><span>等编写的</span><span>DLL</span><span>；另外，一般认为</span><span>C#</span><span>程序的保密性不够强，因为它容易被</span><span>Reflector </span><span>反编译而得到部分源码，所以需要使用混合编程加强</span><span>C#</span><span>程序的保密性，而把</span><span>DLL</span><span>嵌入</span><span>C#</span><span>程序并实现动态调用的方法是比较理想的方法，因为可以把</span><span>DLL</span><span>文件先用某一算法进行加密甚至压缩后再作为资源文件添加到</span><span>C#</span><span>程序中，在程序运行时才用某一算法进行解压解密后才进行加载，所以即使用反编译软件，也只能得到一个资源文件，且这个资源文件是用一个复杂算法进行加密过的，不可能再次对资源文件中的内容进行反编译，从而大大加强了代码的保密性。</span>

<span>&nbsp;</span>

<span>&nbsp;</span>

<span>参考文献：</span>

<span>[1]&nbsp; </span><span>引自：</span><span>《什么是</span><span> DLL?</span><span>》，网址：</span><span> <span>[http://support.microsoft.com/default.aspx?scid=kb;zh-cn;815065](http://support.microsoft.com/default.aspx?scid=kb;zh-cn;815065)</span></span>

<span>[2] </span><span>《在</span><span> C# </span><span>中通过</span><span> P/Invoke </span><span>调用</span><span>Win32 DLL</span><span>》</span> <span>Jason Clark </span><span>，</span>

<span>网址：</span><span>[http://www.microsoft.com/china/msdn/library/langtool/vcsharp/ousNET.mspx](http://www.microsoft.com/china/msdn/library/langtool/vcsharp/ousNET.mspx)</span>

<span>[3] </span><span>《深入分析</span><span>Windows</span><span>和</span><span>Linux</span><span>动态库应用异同》刘世栋</span><span> </span><span>杨林，</span>

<span>网址：</span><span>[http://tech.ccidnet.com/art/302/20050919/336005_1.html](http://tech.ccidnet.com/art/302/20050919/336005_1.html)</span>

<span>[4] </span><span>《</span><span>C# </span><span>程序设计》</span><span> Jesse Liberty </span><span>著</span><span> </span><span>刘基诚</span><span> </span><span>译</span><span>,</span><span>中国电力出版社</span>

Trackback: http://tb.blog.csdn.net/TrackBack.aspx?PostId=568096

</div>

**[温馨提示]：该文章由原博客园导入而来，如排版效果不佳，请移步：[http://www.cnblogs.com/coderzh/archive/2007/12/27/1016924.html](http://www.cnblogs.com/coderzh/archive/2007/12/27/1016924.html)**